'use strict';

var elixir_front = angular.module('elixir_front', [
	'elixir_front.filters',
	'elixir_front.services',
	'elixir_front.directives',
	'elixir_front.controllers',
	'ui.bootstrap',
	'ngCookies',
	'ngRoute',
	'ngSanitize',
	'ngAnimate',
	'ngResource',
	'ui.router',
	'angularBootstrapNavTree',
	'treeControl',
	'720kb.tooltips',
	'yaru22.angular-timeago',
	'angularDjangoRegistrationAuthApp',
	'ngTagsInput',
	'pasvaz.bindonce',
	'ui.grid',
	'ui.grid.resizeColumns',
	'ui.grid.autoResize',
	'ui.grid.saveState',
	'ui.grid.moveColumns',
	'chart.js',
	'ngMeta'
], function($rootScopeProvider) {})

// setting up router and states
.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) {
	// default state
	$urlRouterProvider.when('', '/');
	// for any unmatched url, send to 404
	$urlRouterProvider.otherwise('/404');
	$stateProvider
	.state('404', {
		url: "/404",
		templateUrl: "partials/404.html",
		data: {
			meta: {
				'title': 'Page not found'
		},
			roles: []
		},
		resolve: {}
	})
	.state('home', {
		url: "/",
		templateUrl: "components/home/home.html",
		data: {
			meta: {
				'title': 'bio.tools · Bioinformatics Tools and Services Discovery Portal',
				'description': 'A registry of bioinformatics software resources including biological databases, analytical tools and data services',
				'titleSuffix': '',
				'og:title': 'bio.tools · Bioinformatics Tools and Services Discovery Portal',
				'og:description': 'A registry of bioinformatics software resources including biological databases, analytical tools and data services',
				'og:image': 'https://bio.tools/img/ELIXIR_logo_white_background_small.png'
			},
			roles: []
		},
		resolve: {}
	})
	.state('about', {
		url: "/about",
		templateUrl: "components/about/about.html",
		data: {
			meta: {
				'title': 'About',
				'description': 'A registry of bioinformatics software resources including biological databases, analytical tools and data services'
			},
			roles: []
		},
		resolve: {}
	})
	.state('community', {
		url: "/community",
		templateUrl: "components/community/community.html",
		data: {
			meta: {
				'title': 'Communities in bio.tools',
				'description': 'bio.tools and communities'
			},
			roles: []
		},
		resolve: {}
	})
	.state('communities', {
		url: "/communities",
		templateUrl: "components/community/community.html",
		data: {
			meta: {
				'title': 'Communities',
				'description': 'bio.tools and communities'
			},
			roles: []
		},
		resolve: {}
	})
	.state('schema', {
		url: "/schema",
		templateUrl: "partials/schema.html",
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('stats', {
		url: "/stats",
		templateUrl: "components/stats/stats.html",
		data: {
			meta: {
				'title': 'Stats',
				'description': 'bio.tools content statistics.'
			},
			roles: []
		},
		controller: "StatsController",
		resolve: {}
	})
	.state('search', {
		url: "/t?page&q&biotoolsID&name&topic&function&operation&input&inputDataFormat&inputDataType&output&outputDataFormat&outputDataType&homepage&description&version&accessibility&toolType&collectionID&maturity&operatingSystem&language&cost&license&documentation&link&download&publication&credit&owner&sort&ord&domain&topicID&operationID&dataType&dataTypeID&dataFormat&dataFormatID&inputID&inputDataTypeID&inputDataFormatID&outputID&outputDataTypeID&outputDataFormatID&creditName&creditTypeRole&creditTypeEntity&creditOrcidID&publicationID&publicationType&publicationVersion&linkType&documentationType&downloadType&downloadVersion&otherID&otherIDType&otherIDVersion&otherIDValue&elixirPlatform&elixirNode&elixirCommunity&creditGridID&creditRORID&creditFundRefID",
		templateUrl: "partials/search_results.html",
		data: {
			meta: {
				'title': 'bio.tools · Bioinformatics Tools and Services Discovery Portal',
				'description': 'A registry of bioinformatics software resources including biological databases, analytical tools and data services',
				'titleSuffix': '',
				'og:title': 'bio.tools · Bioinformatics Tools and Services Discovery Portal',
				'og:description': 'A registry of bioinformatics software resources including biological databases, analytical tools and data services',
				'og:image': 'https://bio.tools/img/ELIXIR_logo_white_background_small.png'
			},
			roles: []
		},
		controller: "SearchResultController"
	})
	.state('domains', {
		url: "/domains",
		templateUrl: "partials/subdomains/domains.html",
		data: {
			meta: {
				'title': 'bio.tools domains',
				'description': 'Explore and search all bio.tools domains and manage your own domains.',
				'og:title': 'bio.tools domains',
				'og:description': 'Explore and search all bio.tools domains and manage your own domains.'
			},
			roles: []
		},
		controller: "DomainListController",
		resolve: {}
	})
	.state('register', {
		url: "/register",
		templateUrl: "partials/toolEdit.html",
		data: {
			meta: {
				'title': 'Register new resource',
				'description': 'Register a tool or database in bio.tools.',
				'og:title': 'Register new resource',
				'og:description': 'Register a tool or database in bio.tools.'
		},
			roles: ['User']
		},
		controller: "ToolCreateController",
		resolve: {}
	})
	.state('edit-subdomain', {
		url: "/edit-subdomain/:id",
		templateUrl: "partials/subdomains/subdomainEdit.html",
		data: {
			meta: {
				'title': 'Edit domain',
				'og:title': 'Edit domain'
			},
			roles: ['User']
		},
		controller: "SubdomainController",
		resolve: {}
	})
	.state('edit-domain', {
		url: "/edit-domain/:id",
		templateUrl: "partials/subdomains/subdomainEdit.html",
		data: {
			meta: {
				'title': 'Edit domain',
				'og:title': 'Edit domain'
			},
			roles: ['User']
		},
		controller: "SubdomainController",
		resolve: {}
	})
	.state('admin-subdomain', {
		url: "/subdomain",
		templateUrl: "partials/subdomains/subdomainPage.html",
		data: {
			meta: {
				'title': 'Domain',
				'og:title': 'Domain'
			},
			roles: ['User']
		},
		controller: "SubdomainAdminController",
		resolve: {}
	})
	.state('admin-domain', {
		url: "/domain-manager",
		templateUrl: "partials/subdomains/subdomainPage.html",
		data: {
			meta: {
				'title': 'Domain',
				'og:title': 'Domain'
			},
			roles: ['User']
		},
		controller: "SubdomainAdminController",
		resolve: {}
	})
	.state('login', {
		url: "/login",
		templateUrl: "partials/login.html",
		data: {
			meta: {
				'title': 'Log in',
				'description': 'Log in to bio.tools.',
				'og:title': 'Log in',
				'og:description': 'Log in to bio.tools.'
			},
			roles: []
		},
		controller: "LoginController",
		resolve: {}
	})
	.state('signup', {
		url: "/signup",
		templateUrl: "partials/signup.html",
		data: {
			meta: {
				'title': 'Sign up',
				'description': 'Sign up for bio.tools.',
				'og:title': 'Sign up',
				'og:description': 'Sign up for bio.tools.'
			},
			roles: []
		},
		controller: "SignupController"
	})
	.state('signup.success', {
		url: "/success",
		templateUrl: "partials/signupSuccess.html",
		data: {
			meta: {
				'title': 'Sign up success'
			},
			roles: []
		}
	})
	.state('signup.verify-email', {
		abstract: true,
		url: "/verify-email",
		template: "<ui-view/>",
		data: {
			meta: {
				'title': 'Verify email'
			},
			roles: []
		}
	})
	.state('signup.verify-email.success', {
		url: "/success",
		templateUrl: "partials/signupVerifyEmailSuccess.html",
		data: {
			meta: {
				'title': 'Verification success'
			},
			roles: []
		}
	})
	.state('signup.verify-email.key', {
		url: "/:key",
		templateUrl: "partials/signupVerifyEmailKey.html",
		data: {
			meta: {
				'title': 'Verify email'
			},
			roles: []
		},
		controller: "SignupVerifyEmailKeyController"
	})
	.state('reset-password', {
		url: "/reset-password",
		templateUrl: "partials/resetPassword.html",
		data: {
			meta: {
				'title': 'Reset password'
			},
			roles: []
		},
		controller: "ResetPasswordController"
	})
	.state('reset-password.confirm', {
		url: "/confirm?uid&token",
		templateUrl: "partials/resetPasswordConfirm.html",
		data: {
			meta: {
				'title': 'Reset password'
			},
			roles: []
		},
		controller: "ResetPasswordConfirmController"
	})
	.state('reset-password.confirm.success', {
		url: "/success",
		templateUrl: "partials/resetPasswordConfirmSuccess.html",
		data: {
			meta: {
				'title': 'Reset password success'
			},
			roles: []
		}
	})
	.state('profile', {
		url: "/profile",
		templateUrl: "components/profile/profile.html",
		data: {
			meta: {
				'title': 'My profile'
			},
			roles: []
		},
		controller: "ProfileController"
	})
	.state('subdomain', {
		url: "/t?:domain"
	})
	.state('requests', {
		url: "/requests",
		templateUrl: "partials/requests.html",
		data: {
			roles: []
		},
		controller: "RequestsController"
	})
	.state('workflows', {
		url: "/workflows",
		templateUrl: "partials/workflows/workflows.html",
		data: {
			roles: []
		},
		controller: "WorkflowController"
	})
	.state('tool-explicit', {
		url: "/tool/:id",
		templateUrl: "components/toolPage/toolPage.html",
		data: {
			roles: []
		},
		controller: "ToolPageController",
		resolve: {}
	})
	.state('tool-explicit-short', {
		url: "/t/:id",
		templateUrl: "components/toolPage/toolPage.html",
		data: {
			roles: []
		},
		controller: "ToolPageController",
		resolve: {}
	})
	.state('tool', {
		url: "/:id",
		templateUrl: "components/toolPage/toolPage.html",
		data: {
			roles: []
		},
		controller: "ToolPageController",
		resolve: {}
	})
	.state('tool.edit', {
		url: "/edit",
		templateUrl: "partials/toolEdit.html",
		data: {
			roles: ['User']
		},
		controller: "ToolUpdateController",
		resolve: {}
	})
	// redirects
	.state('governance', {
		url: '/governance',
		redirect: 'http://biotools.readthedocs.io/en/latest/governance.html',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('events', {
		url: '/events',
		redirect: 'https://docs.google.com/document/d/1K-6IG_7a-4amstSSOxYjjJ3uDUEg4-WGSSt9jvvO7Ik/edit#heading=h.twop51kvyu80',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('mail', {
		url: '/mail',
		redirect: 'http://elixirmail.cbs.dtu.dk/mailman/listinfo',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('faq', {
		url: '/faq',
		redirect: 'https://docs.google.com/document/d/1WdcY0WQJVdRHz0BAhII7s8gygxKRJaHZC4gOnAC1eqs/edit',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('apidoc', {
		url: '/apidoc',
		redirect: 'https://docs.google.com/document/d/1c1zridWLBNSrWcYyR2fnBfgjWfrUSrT7HJ6Ql6ZCkS4/edit#heading=h.9a2zbl9ka0z0',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('changelog', {
		url: '/changelog',
		redirect: 'https://docs.google.com/document/d/1C5KFu2t4OIAuUpx6dS7Djsa9y3zgicd8naOsAs9QPAY/edit#heading=h.eu5jkfa77et',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('helpdesk', {
		url: '/helpdesk',
		redirect: 'https://elixir-registry.atlassian.net/servicedesk/customer/portal/2/user/login?destination=portal%2F2',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('projects', {
		url: '/projects',
		redirect: 'https://docs.google.com/document/d/1QBIZHBzHxxmvSnOG3xK6t3SCeft5g4AH2rVICLRLmDw/edit#heading=h.a6i4b9p7xdw7',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
	.state('roadmap', {
		url: '/roadmap',
		redirect: 'https://docs.google.com/document/d/17iH72hmwVo205QVEkptv7GTMlqFojatIwMmxVOyuPy8/edit#heading=h.m1jhkecru8xq',
		external: true,
		data: {
			roles: []
		},
		resolve: {}
	})
}])

// enable HTML5 mode which removes the leading # from URL
.config(function($locationProvider) {
	$locationProvider.html5Mode(true).hashPrefix('!')
})

// default settings for tooltips
.config(function(tooltipsConfigProvider) {
	tooltipsConfigProvider.options({
		speed: 'fast',
		try: 0
	})
})

// make redirect states work
.run(function($rootScope, $window) {
	$rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {
		if (toState.external) {
			event.preventDefault();
			$window.open(toState.redirect, '_self');
		}
	});
})

// make ngMeta run and configure
.run(['ngMeta', function(ngMeta) { 
  ngMeta.init();
}])
.config(function(ngMetaProvider) {

    ngMetaProvider.useTitleSuffix(true);
    ngMetaProvider.setDefaultTitle('bio.tools');
    // ngMetaProvider.setDefaultTitleSuffix(' · bio.tools');
    // ngMetaProvider.setDefaultTag('author', 'John Smith');
})

// user authentication
.run(['$rootScope', '$state', '$timeout', 'User', 'djangoAuth', '$http', function($rootScope, $state, $timeout, User, djangoAuth, $http) {
	User.authenticated = false;

	// what happens on User login
	var logInCallback = function(){
		User.authenticated = true;
		// get user profile
		djangoAuth.profile().then(function (response) {
			User.current = response;
		});
	};

	// what happens on authentication errors
	var wrongAuthCallback = function() {
		delete $http.defaults.headers.common.Authorization;
		delete localStorage.token;
		User.authenticated = false;
		User.current = {};
	};

	// what happens on User logout
	var logOutCallback = function() {
		wrongAuthCallback();
		$state.go('home');
	}

	// get initial authentication status
	var authenticationPromise = djangoAuth.authenticationStatus(true).then(logInCallback, wrongAuthCallback);

	// set relevant callbacks for log in/out events
	$rootScope.$on('djangoAuth.logged_in', logInCallback);
	$rootScope.$on('djangoAuth.logged_out', logOutCallback);

	// checking authentication on state change
	$rootScope.$on('$stateChangeStart', function(event, toState, toStateParams, fromState, fromStateParams) {
		// save current state transitions
		if (toState.name != 'login') {
			$rootScope.toState = toState;
			$rootScope.toStateParams = toStateParams;
		}
		$rootScope.fromState = fromState;

		// pausing the state change, so that the user authentication has a chance to proceed before state change
		if (typeof toState.resolve == 'undefined') { toState.resolve = {} };
		toState.resolve.pauseStateChange = ['$q', function($q) {
				var defer = $q.defer();
				authenticationPromise.then(function () {
					if (!User.authenticated && _.includes(toState.data.roles, 'User')) {
						event.preventDefault();
						// save destination states to return to them on proper login
						$rootScope.returnToState = $rootScope.toState;
						$rootScope.returnToStateParams = $rootScope.toStateParams;
						// direct unauthenticated user to login
						$state.go('login');
					}
					defer.resolve();
				});
				return defer.promise;
			}
		]
	});
	// on error go to 404
	$rootScope.$on('$stateChangeError', function(event) {
		$state.go('404');
	});
}])

// filling in title and description meta attributes in header
.run(["$rootScope", "$timeout", "$state", function($rootScope, $timeout, $state) {
	function getTextValue(text) {
		return angular.isFunction(text) ? text() : text;
	}

	$rootScope.$on("$stateChangeSuccess", function() {
		var title = getTextValue($state.$current.locals.globals.$title);
		var description = getTextValue($state.$current.locals.globals.$description);
		if(title) {
			$timeout(function() {
				$rootScope.$title = title;
			});
		}
		if(description) {
			$timeout(function() {
				$rootScope.$description = description;
			});
		}
	});
}])

'use strict';

/* Controllers */

angular.module('elixir_front.controllers', [])
.controller('ToolGridController', ['$scope', '$timeout', 'ToolList', 'ToolTableDataSource', function ($scope, $timeout, ToolList, ToolTableDataSource) {
	$scope.ToolList = ToolList;
	$scope.savedStateExists = function() {
		return localStorage.getItem('gridState') ? true : false;
	};
	$scope.saveState = function() {
		var state = $scope.gridApi.saveState.save();
		localStorage.setItem('gridState', JSON.stringify(state));
	};
	$scope.restoreState = function() {
		$timeout(function() {
			var state = localStorage.getItem('gridState');
			if (state) $scope.gridApi.saveState.restore($scope, JSON.parse(state));
		});
	};
	$scope.gridOptions = {
		enableSorting: false,
		enableColumnMenus: false,
		enableColumnResizing: true,
		enableVerticalScrollbar: 0,
		enableHorizontalScrollbar: true,
		columnVirtualizationThreshold: ToolTableDataSource.columnsDescription([]).length,
		data: ToolList.list,
		columnDefs: ToolTableDataSource.columnsDescription($scope.savedStateExists() == true ? [] : ['Name', 'Description', 'Homepage', 'Credits', 'Operation', 'Topic', 'Input', 'Output']),
		rowHeight: 135,
		enableGridMenu: true,
		onRegisterApi: function(gridApi) {
			$scope.gridApi = gridApi;
			$scope.restoreState();
			// Setup events so we're notified when grid state changes.
			$scope.gridApi.core.on.columnVisibilityChanged($scope, function (column) {
				$scope.saveState();
			});
			$scope.gridApi.colResizable.on.columnSizeChanged($scope, function (column) {
				$scope.saveState();
			});
			$scope.gridApi.colMovable.on.columnPositionChanged($scope, function (column) {
				$scope.saveState();
			});
		}
	};
	$scope.tableHeight = function() {
		return {"height": ((Math.min($scope.ToolList.count, 10) * $scope.gridOptions.rowHeight) + 33) + "px"};
	}
}])
.controller('ToolGridCellController', ['$scope', function ($scope) {
	$scope.init = function(columnName, rowIndex) {
		$scope.columnName = columnName;
		$scope.rowIndex = rowIndex;
	}
	$scope.RowIdentifier = function() {
		return $scope.columnName+$scope.rowIndex;
	}
	$scope.RowName = function() {
		return $scope.columnName;
	}
	$scope.RowHeight = function() {
		var element = document.getElementById($scope.RowIdentifier());
		return (element) ? element.offsetHeight : 0;
	}
	$scope.DefaultRowHeight = function() {
		return 135;
	}
	$scope.CellWidth = function() {
		return document.getElementById($scope.RowIdentifier()).offsetWidth;
	}
	$scope.CellStyle = function() {
		return {'width': CellWidthDescription(),
		'background-color': CellColorDescription()};
	}
	function CellWidthDescription() {
		return ($scope.CellWidth() + 2) + "px";
	}
	function CellColorDescription() {
		return $scope.rowIndex % 2 != 0 ? "#f8f8f8" : "white";
	}
}])
.controller('SearchResultController', ['$scope','$state', 'ToolList', 'ToolTableDataSource', 'DisplayModeSelector', 'Domain', function($scope, $state, ToolList, ToolTableDataSource, DisplayModeSelector, Domain){

	function quoteQueryStringValue(v){
		return '"' + v + '"'
	}

	function stripEdam(t){
		return t.replace("http://edamontology.org/", "");
	}

	$scope.topicNameClicked = function(topic) {
		//$state.go('search', {'topic': topic.term}, {reload: true});
		$state.transitionTo('search', {'topicID': quoteQueryStringValue(stripEdam(topic.uri))},
		{
		reload: true,
		inherit: false,
		notify: true
		});
	}

	$scope.operationNameClicked = function(operation) {
		//$state.go('search', {'topic': topic.term}, {reload: true});
		$state.transitionTo('search', {'operationID': quoteQueryStringValue(stripEdam(operation.uri))},
		{
		reload: true,
		inherit: false,
		notify: true
		});
	}
	$scope.collectionNameClicked = function(collection) {
		//$state.go('search', {'topic': topic.term}, {reload: true});
		$state.transitionTo('search', {'collectionID': quoteQueryStringValue(collection)},
		{
		reload: true,
		inherit: false,
		notify: true
		});
	}

	$scope.shouldLicenseBeALink = function(license) {
  	return !_.includes(['Freeware','Proprietary', 'Other', 'Not licensed'], license);
	}

	$scope.getFlatOperations = function(functions){

		var operations = {};
		for (var i = 0; i < functions.length; i++){
			for (var j = 0; j < functions[i].operation.length; j++){
				var o = functions[i].operation[j];
				operations[o.term] = o;
			}
		}

		var arr = Object.keys(operations);
		var r = [];
		for (var i = 0; i < arr.length;i++){
			r.push(operations[arr[i]]);
		}

		return r;
	}

	$scope.Domain = Domain;
	$scope.ToolTableDataSource = ToolTableDataSource;
	$scope.ToolList = ToolList;
	$scope.DisplayModeSelector = DisplayModeSelector;
	// Get data initially
	ToolList.refresh();
}])
.controller('AlertsController', ['$scope', 'Alert', 'EnvironmentChecker', function($scope, Alert, EnvironmentChecker){
	$scope.Alert = Alert;
	$scope.dev_alert = false;

	// check if the current setup id dev or prod.
	EnvironmentChecker.getEnvironment().then(function(data) {
		if (data == 'Development') {
			$scope.dev_alert = true;
		}
	});

	// check if cookie info was disabled for this user
	if ('cookie_alert' in localStorage) {
		$scope.cookie_alert = (localStorage.cookie_alert === 'true');
	} else {
		$scope.cookie_alert = true;
	}

	// check if welcome message was disabled for this user
	if ('welcome_message' in localStorage) {
		$scope.welcome_message = (localStorage.welcome_message === 'true');
	} else {
		$scope.welcome_message = true;
	}

	$scope.closeCookieInfoButtonClick = function() {
		$scope.cookie_alert = false;
		localStorage.cookie_alert = false;
	};

	$scope.closeWelcomeMessageButtonClick = function() {
		$scope.welcome_message = false;
		localStorage.welcome_message = false;
	};
}])
.controller('ToolEditController', ['$scope', '$controller', '$state', '$stateParams', 'Ontology', 'Attribute', 'CheckUserEditingRights', 'User', '$timeout', 'UsedTerms','$q','$modal', function($scope, $controller, $state, $stateParams, Ontology, Attribute, CheckUserEditingRights, User, $timeout, UsedTerms, $q, $modal ) {

	// reference the service
	$scope.Attribute = Attribute;
	$scope.CheckUserEditingRights = CheckUserEditingRights;
	$scope.$state = $state;
	$scope.form = {};
	$scope.canEditTool = false;
	$scope.canEditToolPermissions = false;
	$scope.User = User;
	$scope.orderby = 'text';
	
	$scope.registeringInProgress = false;
	

	// for storing validation and saving progess
	$scope.validationProgress = {}, $scope.savingProgress = {}, $scope.deletingProgress = {};

	$scope.initializePermissions = function() {
		$scope.canEditTool = false;
		$scope.canEditToolPermissions = false;
		// Owner can edit anything.
		if (!_.isEmpty($scope.software)){
			if ($scope.software.owner == $scope.User.getUsername()) {
				$scope.canEditTool = true;
				$scope.canEditToolPermissions = true;
			}
			else if ($scope.software.editPermission != undefined) {
				$scope.canEditTool = $scope.CheckUserEditingRights.canEdit($scope.software);
				$scope.canEditToolPermissions = false;
				delete $scope.software.editPermission;
			}
		}
	}

	// handle sending the resource to either validation or saving endpoints
	$scope.sendResource = function(service, progress, isRemoval, action) {
		progress.success = false;
		progress.error = false;
		progress.inProgress = true;
		$scope.registrationErrorPayload = null;

		service($stateParams, $scope.software, function (response) {
			// handle success
			progress.inProgress = false;
			progress.success = true;
			if (isRemoval) {
				alert('Resource removed succesfully.');
				$state.go('search');
			}

			if (action == "create"){
				$state.go('tool.edit', {id: response.biotoolsID});
			}

		}, function(response) {
			// handle error
			progress.error = true;
			progress.inProgress = false;
			$scope.registrationErrorPayload = response.data;
		});
	}

	// modals
	$scope.openModal = function (edam, type, suggestions) {
		var ontoMap = {
			'data': $scope.EDAM_data,
			'format': $scope.EDAM_format,
			'operation': $scope.EDAM_operation
		};
		var onto = ontoMap[type] || $scope.EDAM_data;

		var modalInstance = $modal.open({
			templateUrl: 'partials/tool_edit/toolEditEdamModal.html',
			controllerAs: 'vm',
			controller: ['$modalInstance', 'edam', 'onto', 'type', 'suggestions', EdamModalCtrl],
			resolve: {
				edam: function () { return edam; },
				onto: function () { return onto; },
				type: function () { return type; },
				suggestions: function () { return suggestions; },
			}
		});

		modalInstance.result.then(function (updatedEdam) {
			angular.copy(updatedEdam, edam);
		}, function () { });

		return modalInstance.result;
	}


	$scope.findObjectByUri = function (obj, targetUri) {
		function search(current) {
			if (current.data && current.data.uri === targetUri) {
				return current;
			}
			if (current.children) {
				for (var i = 0; i < current.children.length; i++) {
					var result = search(current.children[i]);
					if (result) return result;
				}
			}
			return null;
		}

		for (var i = 0; i < obj.length; i++) {
			var result = search(obj[i]);
			if (result) return result;
		}
		return null;
	};

	$scope.flattenObject = function (obj) {
		var result = [];
		var stack = [obj];

		while (stack.length > 0) {
			var current = stack.pop();
			for (var key in current) {
				if (current.hasOwnProperty(key)) {
					var value = current[key];
					if (typeof value === 'object' && value !== null) {
						stack.push(value);
					} else {
						result.push(value);
					}
				}
			}
		}
		return result;
	};	

	$scope.recommend_terms = function (edam, type) {
		var edamArray = $scope.flattenObject(edam).filter(function (word) {
			return typeof word === 'string' && word.indexOf('http://edamontology.org/') !== -1;
		});

		if (type === "operation") return null;  // No recommendations for operations

		var ontoMap = {
			'format': $scope.EDAM_data,
			'input': $scope.EDAM_operation,
			'output': $scope.EDAM_operation
		};
		var onto = ontoMap[type] || $scope.EDAM_operation;

		var suggestions = [];

		for (var i = 0; i < edamArray.length; i++) {
			var element = edamArray[i];
			var edamObj = $scope.findObjectByUri(onto, element);
			if (!edamObj) continue;

			var appendSuggestions = getSuggestions(type, edamObj, edam);
			if (appendSuggestions.length) {
				suggestions = suggestions.concat(appendSuggestions);
			}
		}

		return mapSuggestions(suggestions, type);
	};

	function getSuggestions(type, edamObj, edam) {
		switch (type) {
			case 'input':
				return getInputSuggestions(edamObj, edam);
			case 'output':
				return getOutputSuggestions(edamObj, edam);
			default:
				return [];
		}
	}

	function getInputSuggestions(edamObj, edam) {
		if (!edamObj.has_input) return [];
		if (!edam.hasOwnProperty('input')) return edamObj.has_input;
		return edamObj.has_input.filter(function (input) {
			return !edam.input.some(function (existingInput) {
				return existingInput.data.uri === input;
			});
		});
	}

	function getOutputSuggestions(edamObj, edam) {
		if (!edamObj.has_output) return [];
		if (!edam.hasOwnProperty('output')) return edamObj.has_output;
		return edamObj.has_output.filter(function (output) {
			return !edam.output.some(function (existingOutput) {
				return existingOutput.data.uri === output;
			});
		});
	}

	function mapSuggestions(suggestions, type) {
		var ontoMap = {
			'format': $scope.EDAM_format,
			'output': $scope.EDAM_data,
			'input': $scope.EDAM_data
		};
		var onto = ontoMap[type];

		return suggestions.map(function (element) {
			var edamObj = $scope.findObjectByUri(onto, element);
			return {
				'uri': element,
				'term': edamObj ? edamObj.text : ''
			};
		});
	}

	$scope.addWithModal = function (type, edam) {
		var pickerTypeMap = {
			'input': 'data',
			'output': 'data',
			'format': 'format',
			'function': 'operation',
			'operation': 'operation'
		};
		var pickertype = pickerTypeMap[type] || '';

		var suggestions = $scope.recommend_terms(edam, type);

		var modalPromise = $scope.openModal({}, pickertype, suggestions);

		modalPromise.then(function (newEdam) {
			handleModalResult(type, edam, newEdam);
		}, function () { });
	};

	function handleModalResult(type, edam, newEdam) {
		switch (type) {
			case 'format':
				$scope.addButtonClick('format', edam, true, true);
				edam.format[edam.format.length - 1] = newEdam;
				break;
			case 'output':
				$scope.addButtonClick('output', edam, true, true);
				edam.output[edam.output.length - 1] = newEdam;
				break;
			case 'input':
				$scope.addButtonClick('input', edam, true, true);
				edam.input[edam.input.length - 1] = newEdam;
				break;
			case 'function':
				$scope.addButtonClick('function', edam, true, true);
				edam.function[edam.function.length - 1].operation = [newEdam];
				break;
			case 'operation':
				$scope.addButtonClick('function', edam, true, true);
				edam.push(newEdam);
				break;
		}
	}
	
	// used terms (biotoolsID) for searching in relations
	function getBiotoolsIDs(){
		var d = $q.defer();
		var params = {
			"usedTermName": "biotoolsID"
		};
		UsedTerms.get(params, function(response) {
			d.resolve(response.data);
		});
		return d.promise;
	}
	
	$scope.loadBiotoolsIDs = function(query) {
		return getBiotoolsIDs().then(function(list) {
			return list.filter(function (str) { return str.toLowerCase().includes(query.toLowerCase()); }).slice(0,50).sort();
		});
	}

	// used terms (collectionID) for searching in collections
	function getCollectionIDs(){
		var d = $q.defer();
		var params = {
			"usedTermName": "collectionID"
		};
		UsedTerms.get(params, function(response) {
			d.resolve(response.data);
		});
		return d.promise;
	}
	
	$scope.loadCollectionIDs = function(query) {
		return getCollectionIDs().then(function(list) {
			return list.filter(function (str) { return str.toLowerCase().includes(query.toLowerCase()); }).slice(0,10).sort();
		});
	}

	// used terms (credit names) for searching in credits
	function getCreditNames(){
		var d = $q.defer();
		var params = {
			"usedTermName": "credit"
		};
		UsedTerms.get(params, function(response) {
			d.resolve(response.data);
		});
		return d.promise;
	}
	
	$scope.loadCreditNames = function(query) {
		return getCreditNames().then(function(list) {
			return list.filter(function (str) { return str.toLowerCase().includes(query.toLowerCase()); }).slice(0,10).sort();
		});
	}



	// add attribute or list entry
	$scope.addButtonClick = function (_what, _where, _isList, _isObject) {
		if (_isList) {
			// if array does not exist create it
			if (typeof _where[_what] == 'undefined') {
				_where[_what] = [];
			}
			// add either an object or string to array
			_where[_what].push(_isObject ? {} : '');
		} else {
			// if object does not exist create it
			if (typeof _where[_what] == 'undefined') {
				_where[_what] = _isObject ? {} : '';
			}
		}
	}

	$scope.addObjectClick = function(_what, _parent, _where){
		_parent[_where] = {}
		_parent[_where][_what] = {}

	}

	$scope.removeObjectClick = function(_what, _parent, _where){
		var message = _parent[_what][_index].term ? `Are you sure you want to remove ${_parent[_what][_index].term}?` : "Are you sure you want to remove this element?"

		if (confirm(message)){
			if (_parent[_where][_what]){
				delete _parent[_where][_what];
			}
			if (Object.keys(_parent[_where]).length === 0){
				delete _parent[_where];
			}
		}
	}

	// remove attribute or list entry
	$scope.removeButtonClick = function (_what, _parent, _index, _event) {
		var message = _parent[_what][_index].term 
			? `Are you sure you want to remove ${_parent[_what][_index].term}?` 
			: "Are you sure you want to remove this element?";
	
		if (_parent[_what][_index] ? confirm(message) : true) {
			// remove jstree if exists
			if (_event) {
				$(_event.target).closest('div').find('.jstree').jstree("destroy").remove();
			}
	
			_parent[_what].splice(_index, 1);
	
			// if last instance in array delete entire attribute from the parent object
			if (_parent[_what].length == 0) {
				delete _parent[_what];
	
				// If we're removing an operation and it's the last one, remove the entire function
				if (_what === 'operation') {
					var functionIndex = $scope.software.function.indexOf(_parent);
					if (functionIndex > -1) {
						$scope.software.function.splice(functionIndex, 1);
					}
				}
			}
		}
	};	

	// create connections between entries
	$scope.errorConnections = {
		"name" : ["id"]
	};

	// reset error on change
	$scope.resetError = function (_what, _parent, _index) {
		// select appropriate error type handling
		if (_index != undefined && _index >= 0) {
			$scope.resetListError(_what, _parent, _index);
		}
		else {
			// remove all connected error warnings
			var whatConnections = $scope.errorConnections[_what];
			if (whatConnections) {
				whatConnections.forEach( function(connection) {
					if (_parent != undefined && _parent[connection]) {
						delete _parent[connection];
					}
				});
			}
			// remove the actual error
			if (_parent != undefined && _parent[_what]) {
				delete _parent[_what];
			}

		}
	}

	$scope.resetListError = function (_what, _parent, _index) {
		if (_parent[_what] && _parent[_what][_index]) {
			_parent[_what][_index] = {};
		}
	}

	$scope.isString = function(value) {
		if (typeof value === 'string') {
			return true;
		} else {
			return false;
		}
	}

	// get ontology objects for the various widgets
	Ontology.get({"name":"EDAM_topic"}, function(response) {$scope.EDAM_topic = response.data.children});
	Ontology.get({"name":"EDAM_data"}, function(response) {$scope.EDAM_data = response.data.children});
	Ontology.get({"name":"EDAM_format"}, function(response) {$scope.EDAM_format = response.data.children});
	Ontology.get({"name":"EDAM_operation"}, function(response) {$scope.EDAM_operation = response.data.children});

	// populate the JSON edit textarea
	$scope.$watch('software', function(newVal, oldVal) {
		$scope.jsonEdit.model = angular.toJson($scope.software, 2);
		// Check permissions
		if ($scope.canEditTool == false) {
				$scope.initializePermissions();
		}
	}, true);

	// parse the edited JSON for errors
	$scope.jsonEdit = {};
	var initializing = true;
	$scope.$watch('jsonEdit.model', function (newVal, oldVal) {
		if (!initializing) {
			try {
				$scope.software = angular.fromJson($scope.jsonEdit.model);
				$scope.jsonEdit.error = null;
			} catch(exp) {
				$scope.jsonEdit.error = exp.message;
			};
		} else {
			initializing = false;
		}

	});

	// download JSON from the editor
	$scope.downloadTool = function(_pretty) {
		var hiddenElement = document.createElement('a');
		if (_pretty) {
			hiddenElement.href = 'data:attachment/json,' + encodeURI(angular.toJson($scope.software, 2));
		} else {
			hiddenElement.href = 'data:attachment/json,' + encodeURI(angular.toJson($scope.software));
		}
		hiddenElement.target = '_blank';
		hiddenElement.download = ($scope.software.name ? $scope.software.name : 'resource') + '.json';
		document.body.appendChild(hiddenElement);
		hiddenElement.click();
	}

	// settings for the EDAM tree widget
	$scope.treeOptions = {
		nodeChildren: "children",
		dirSelectable: true
	}


	// set term and uri when picked from EDAM widget
	$scope.ontologyOnSelect = function (_object, _index, _node) {
		// if _object[_index] is not an object, make it one
		if ( !(_object[_index] === Object(_object[_index]) ) ) {
			_object[_index] = {};
		}
		_object[_index].term = _node.text;
		_object[_index].uri = _node.data.uri;
	}

	$scope.latestOptions = [
		{value: 1, text: "Yes"},
		{value: 0, text: "No"}
	];

	$scope.contactRoleOptions = [
		{value: "General", text: "General"},
		{value: "Developer", text: "Developer"},
		{value: "Technical", text: "Technical"},
		{value: "Scientific", text: "Scientific"},
		{value: "Helpdesk", text: "Helpdesk"},
		{value: "Maintainer", text: "Maintainer"}
	];

	$scope.licenseOptions = [
		{value: "Freeware", text: "Freeware"},
		{value: "Proprietary", text: "Proprietary"},
		{value: "Other", text: "Other"},
		{value: "Not licensed", text: "Not licensed"},
		{value: "0BSD", text: "0BSD"},
		{value: "AAL", text: "AAL"},
		{value: "ADSL", text: "ADSL"},
		{value: "AFL-1.1", text: "AFL-1.1"},
		{value: "AFL-1.2", text: "AFL-1.2"},
		{value: "AFL-2.0", text: "AFL-2.0"},
		{value: "AFL-2.1", text: "AFL-2.1"},
		{value: "AFL-3.0", text: "AFL-3.0"},
		{value: "AGPL-1.0", text: "AGPL-1.0"},
		{value: "AGPL-3.0", text: "AGPL-3.0"},
		{value: "AMDPLPA", text: "AMDPLPA"},
		{value: "AML", text: "AML"},
		{value: "AMPAS", text: "AMPAS"},
		{value: "ANTLR-PD", text: "ANTLR-PD"},
		{value: "APAFML", text: "APAFML"},
		{value: "APL-1.0", text: "APL-1.0"},
		{value: "APSL-1.0", text: "APSL-1.0"},
		{value: "APSL-1.1", text: "APSL-1.1"},
		{value: "APSL-1.2", text: "APSL-1.2"},
		{value: "APSL-2.0", text: "APSL-2.0"},
		{value: "Abstyles", text: "Abstyles"},
		{value: "Adobe-2006", text: "Adobe-2006"},
		{value: "Adobe-Glyph", text: "Adobe-Glyph"},
		{value: "Afmparse", text: "Afmparse"},
		{value: "Aladdin", text: "Aladdin"},
		{value: "Apache-1.0", text: "Apache-1.0"},
		{value: "Apache-1.1", text: "Apache-1.1"},
		{value: "Apache-2.0", text: "Apache-2.0"},
		{value: "Artistic-1.0", text: "Artistic-1.0"},
		{value: "Artistic-1.0-Perl", text: "Artistic-1.0-Perl"},
		{value: "Artistic-1.0-cl8", text: "Artistic-1.0-cl8"},
		{value: "Artistic-2.0", text: "Artistic-2.0"},
		{value: "BSD-2-Clause", text: "BSD-2-Clause"},
		{value: "BSD-2-Clause-FreeBSD", text: "BSD-2-Clause-FreeBSD"},
		{value: "BSD-2-Clause-NetBSD", text: "BSD-2-Clause-NetBSD"},
		{value: "BSD-3-Clause", text: "BSD-3-Clause"},
		{value: "BSD-3-Clause-Attribution", text: "BSD-3-Clause-Attribution"},
		{value: "BSD-3-Clause-Clear", text: "BSD-3-Clause-Clear"},
		{value: "BSD-3-Clause-LBNL", text: "BSD-3-Clause-LBNL"},
		{value: "BSD-3-Clause-No-Nuclear-License", text: "BSD-3-Clause-No-Nuclear-License"},
		{value: "BSD-3-Clause-No-Nuclear-License-2014", text: "BSD-3-Clause-No-Nuclear-License-2014"},
		{value: "BSD-3-Clause-No-Nuclear-Warranty", text: "BSD-3-Clause-No-Nuclear-Warranty"},
		{value: "BSD-4-Clause", text: "BSD-4-Clause"},
		{value: "BSD-4-Clause-UC", text: "BSD-4-Clause-UC"},
		{value: "BSD-Protection", text: "BSD-Protection"},
		{value: "BSD-Source-Code", text: "BSD-Source-Code"},
		{value: "BSL-1.0", text: "BSL-1.0"},
		{value: "Bahyph", text: "Bahyph"},
		{value: "Barr", text: "Barr"},
		{value: "Beerware", text: "Beerware"},
		{value: "BitTorrent-1.0", text: "BitTorrent-1.0"},
		{value: "BitTorrent-1.1", text: "BitTorrent-1.1"},
		{value: "Borceux", text: "Borceux"},
		{value: "CATOSL-1.1", text: "CATOSL-1.1"},
		{value: "CC-BY-1.0", text: "CC-BY-1.0"},
		{value: "CC-BY-2.0", text: "CC-BY-2.0"},
		{value: "CC-BY-2.5", text: "CC-BY-2.5"},
		{value: "CC-BY-3.0", text: "CC-BY-3.0"},
		{value: "CC-BY-4.0", text: "CC-BY-4.0"},
		{value: "CC-BY-NC-1.0", text: "CC-BY-NC-1.0"},
		{value: "CC-BY-NC-2.0", text: "CC-BY-NC-2.0"},
		{value: "CC-BY-NC-2.5", text: "CC-BY-NC-2.5"},
		{value: "CC-BY-NC-3.0", text: "CC-BY-NC-3.0"},
		{value: "CC-BY-NC-4.0", text: "CC-BY-NC-4.0"},
		{value: "CC-BY-NC-ND-1.0", text: "CC-BY-NC-ND-1.0"},
		{value: "CC-BY-NC-ND-2.0", text: "CC-BY-NC-ND-2.0"},
		{value: "CC-BY-NC-ND-2.5", text: "CC-BY-NC-ND-2.5"},
		{value: "CC-BY-NC-ND-3.0", text: "CC-BY-NC-ND-3.0"},
		{value: "CC-BY-NC-ND-4.0", text: "CC-BY-NC-ND-4.0"},
		{value: "CC-BY-NC-SA-1.0", text: "CC-BY-NC-SA-1.0"},
		{value: "CC-BY-NC-SA-2.0", text: "CC-BY-NC-SA-2.0"},
		{value: "CC-BY-NC-SA-2.5", text: "CC-BY-NC-SA-2.5"},
		{value: "CC-BY-NC-SA-3.0", text: "CC-BY-NC-SA-3.0"},
		{value: "CC-BY-NC-SA-4.0", text: "CC-BY-NC-SA-4.0"},
		{value: "CC-BY-ND-1.0", text: "CC-BY-ND-1.0"},
		{value: "CC-BY-ND-2.0", text: "CC-BY-ND-2.0"},
		{value: "CC-BY-ND-2.5", text: "CC-BY-ND-2.5"},
		{value: "CC-BY-ND-3.0", text: "CC-BY-ND-3.0"},
		{value: "CC-BY-ND-4.0", text: "CC-BY-ND-4.0"},
		{value: "CC-BY-SA-1.0", text: "CC-BY-SA-1.0"},
		{value: "CC-BY-SA-2.0", text: "CC-BY-SA-2.0"},
		{value: "CC-BY-SA-2.5", text: "CC-BY-SA-2.5"},
		{value: "CC-BY-SA-3.0", text: "CC-BY-SA-3.0"},
		{value: "CC-BY-SA-4.0", text: "CC-BY-SA-4.0"},
		{value: "CC0-1.0", text: "CC0-1.0"},
		{value: "CDDL-1.0", text: "CDDL-1.0"},
		{value: "CDDL-1.1", text: "CDDL-1.1"},
		{value: "CECILL-1.0", text: "CECILL-1.0"},
		{value: "CECILL-1.1", text: "CECILL-1.1"},
		{value: "CECILL-2.0", text: "CECILL-2.0"},
		{value: "CECILL-2.1", text: "CECILL-2.1"},
		{value: "CECILL-B", text: "CECILL-B"},
		{value: "CECILL-C", text: "CECILL-C"},
		{value: "CNRI-Jython", text: "CNRI-Jython"},
		{value: "CNRI-Python", text: "CNRI-Python"},
		{value: "CNRI-Python-GPL-Compatible", text: "CNRI-Python-GPL-Compatible"},
		{value: "CPAL-1.0", text: "CPAL-1.0"},
		{value: "CPL-1.0", text: "CPL-1.0"},
		{value: "CPOL-1.02", text: "CPOL-1.02"},
		{value: "CUA-OPL-1.0", text: "CUA-OPL-1.0"},
		{value: "Caldera", text: "Caldera"},
		{value: "ClArtistic", text: "ClArtistic"},
		{value: "Condor-1.1", text: "Condor-1.1"},
		{value: "Crossword", text: "Crossword"},
		{value: "CrystalStacker", text: "CrystalStacker"},
		{value: "Cube", text: "Cube"},
		{value: "D-FSL-1.0", text: "D-FSL-1.0"},
		{value: "DOC", text: "DOC"},
		{value: "DSDP", text: "DSDP"},
		{value: "Dotseqn", text: "Dotseqn"},
		{value: "ECL-1.0", text: "ECL-1.0"},
		{value: "ECL-2.0", text: "ECL-2.0"},
		{value: "EFL-1.0", text: "EFL-1.0"},
		{value: "EFL-2.0", text: "EFL-2.0"},
		{value: "EPL-1.0", text: "EPL-1.0"},
		{value: "EUDatagrid", text: "EUDatagrid"},
		{value: "EUPL-1.0", text: "EUPL-1.0"},
		{value: "EUPL-1.1", text: "EUPL-1.1"},
		{value: "Entessa", text: "Entessa"},
		{value: "ErlPL-1.1", text: "ErlPL-1.1"},
		{value: "Eurosym", text: "Eurosym"},
		{value: "FSFAP", text: "FSFAP"},
		{value: "FSFUL", text: "FSFUL"},
		{value: "FSFULLR", text: "FSFULLR"},
		{value: "FTL", text: "FTL"},
		{value: "Fair", text: "Fair"},
		{value: "Frameworx-1.0", text: "Frameworx-1.0"},
		{value: "FreeImage", text: "FreeImage"},
		{value: "GFDL-1.1", text: "GFDL-1.1"},
		{value: "GFDL-1.2", text: "GFDL-1.2"},
		{value: "GFDL-1.3", text: "GFDL-1.3"},
		{value: "GL2PS", text: "GL2PS"},
		{value: "GPL-1.0", text: "GPL-1.0"},
		{value: "GPL-2.0", text: "GPL-2.0"},
		{value: "GPL-3.0", text: "GPL-3.0"},
		{value: "Giftware", text: "Giftware"},
		{value: "Glide", text: "Glide"},
		{value: "Glulxe", text: "Glulxe"},
		{value: "HPND", text: "HPND"},
		{value: "HaskellReport", text: "HaskellReport"},
		{value: "IBM-pibs", text: "IBM-pibs"},
		{value: "IC", text: "IC"},
		{value: "IJG", text: "IJG"},
		{value: "IPA", text: "IPA"},
		{value: "IPL-1.0", text: "IPL-1.0"},
		{value: "ISC", text: "ISC"},
		{value: "ImageMagick", text: "ImageMagick"},
		{value: "Imlib2", text: "Imlib2"},
		{value: "Info-ZIP", text: "Info-ZIP"},
		{value: "Intel", text: "Intel"},
		{value: "Intel-ACPI", text: "Intel-ACPI"},
		{value: "Interbase-1.0", text: "Interbase-1.0"},
		{value: "JSON", text: "JSON"},
		{value: "JasPer-2.0", text: "JasPer-2.0"},
		{value: "LAL-1.2", text: "LAL-1.2"},
		{value: "LAL-1.3", text: "LAL-1.3"},
		{value: "LGPL-2.0", text: "LGPL-2.0"},
		{value: "LGPL-2.1", text: "LGPL-2.1"},
		{value: "LGPL-3.0", text: "LGPL-3.0"},
		{value: "LGPLLR", text: "LGPLLR"},
		{value: "LPL-1.0", text: "LPL-1.0"},
		{value: "LPL-1.02", text: "LPL-1.02"},
		{value: "LPPL-1.0", text: "LPPL-1.0"},
		{value: "LPPL-1.1", text: "LPPL-1.1"},
		{value: "LPPL-1.2", text: "LPPL-1.2"},
		{value: "LPPL-1.3a", text: "LPPL-1.3a"},
		{value: "LPPL-1.3c", text: "LPPL-1.3c"},
		{value: "Latex2e", text: "Latex2e"},
		{value: "Leptonica", text: "Leptonica"},
		{value: "LiLiQ-P-1.1", text: "LiLiQ-P-1.1"},
		{value: "LiLiQ-R-1.1", text: "LiLiQ-R-1.1"},
		{value: "LiLiQ-Rplus-1.1", text: "LiLiQ-Rplus-1.1"},
		{value: "Libpng", text: "Libpng"},
		{value: "MIT", text: "MIT"},
		{value: "MIT-CM", text: "MIT-CM"},
		{value: "MIT-advertising", text: "MIT-advertising"},
		{value: "MIT-enna", text: "MIT-enna"},
		{value: "MIT-feh", text: "MIT-feh"},
		{value: "MITNFA", text: "MITNFA"},
		{value: "MPL-1.0", text: "MPL-1.0"},
		{value: "MPL-1.1", text: "MPL-1.1"},
		{value: "MPL-2.0", text: "MPL-2.0"},
		{value: "MPL-2.0-no-copyleft-exception", text: "MPL-2.0-no-copyleft-exception"},
		{value: "MS-PL", text: "MS-PL"},
		{value: "MS-RL", text: "MS-RL"},
		{value: "MTLL", text: "MTLL"},
		{value: "MakeIndex", text: "MakeIndex"},
		{value: "MirOS", text: "MirOS"},
		{value: "Motosoto", text: "Motosoto"},
		{value: "Multics", text: "Multics"},
		{value: "Mup", text: "Mup"},
		{value: "NASA-1.3", text: "NASA-1.3"},
		{value: "NBPL-1.0", text: "NBPL-1.0"},
		{value: "NCSA", text: "NCSA"},
		{value: "NGPL", text: "NGPL"},
		{value: "NLOD-1.0", text: "NLOD-1.0"},
		{value: "NLPL", text: "NLPL"},
		{value: "NOSL", text: "NOSL"},
		{value: "NPL-1.0", text: "NPL-1.0"},
		{value: "NPL-1.1", text: "NPL-1.1"},
		{value: "NPOSL-3.0", text: "NPOSL-3.0"},
		{value: "NRL", text: "NRL"},
		{value: "NTP", text: "NTP"},
		{value: "Naumen", text: "Naumen"},
		{value: "NetCDF", text: "NetCDF"},
		{value: "Newsletr", text: "Newsletr"},
		{value: "Nokia", text: "Nokia"},
		{value: "Noweb", text: "Noweb"},
		{value: "Nunit", text: "Nunit"},
		{value: "OCCT-PL", text: "OCCT-PL"},
		{value: "OCLC-2.0", text: "OCLC-2.0"},
		{value: "ODbL-1.0", text: "ODbL-1.0"},
		{value: "OFL-1.0", text: "OFL-1.0"},
		{value: "OFL-1.1", text: "OFL-1.1"},
		{value: "OGTSL", text: "OGTSL"},
		{value: "OLDAP-1.1", text: "OLDAP-1.1"},
		{value: "OLDAP-1.2", text: "OLDAP-1.2"},
		{value: "OLDAP-1.3", text: "OLDAP-1.3"},
		{value: "OLDAP-1.4", text: "OLDAP-1.4"},
		{value: "OLDAP-2.0", text: "OLDAP-2.0"},
		{value: "OLDAP-2.0.1", text: "OLDAP-2.0.1"},
		{value: "OLDAP-2.1", text: "OLDAP-2.1"},
		{value: "OLDAP-2.2", text: "OLDAP-2.2"},
		{value: "OLDAP-2.2.1", text: "OLDAP-2.2.1"},
		{value: "OLDAP-2.2.2", text: "OLDAP-2.2.2"},
		{value: "OLDAP-2.3", text: "OLDAP-2.3"},
		{value: "OLDAP-2.4", text: "OLDAP-2.4"},
		{value: "OLDAP-2.5", text: "OLDAP-2.5"},
		{value: "OLDAP-2.6", text: "OLDAP-2.6"},
		{value: "OLDAP-2.7", text: "OLDAP-2.7"},
		{value: "OLDAP-2.8", text: "OLDAP-2.8"},
		{value: "OML", text: "OML"},
		{value: "OPL-1.0", text: "OPL-1.0"},
		{value: "OSET-PL-2.1", text: "OSET-PL-2.1"},
		{value: "OSL-1.0", text: "OSL-1.0"},
		{value: "OSL-1.1", text: "OSL-1.1"},
		{value: "OSL-2.0", text: "OSL-2.0"},
		{value: "OSL-2.1", text: "OSL-2.1"},
		{value: "OSL-3.0", text: "OSL-3.0"},
		{value: "OpenSSL", text: "OpenSSL"},
		{value: "PDDL-1.0", text: "PDDL-1.0"},
		{value: "PHP-3.0", text: "PHP-3.0"},
		{value: "PHP-3.01", text: "PHP-3.01"},
		{value: "Plexus", text: "Plexus"},
		{value: "PostgreSQL", text: "PostgreSQL"},
		{value: "Python-2.0", text: "Python-2.0"},
		{value: "QPL-1.0", text: "QPL-1.0"},
		{value: "Qhull", text: "Qhull"},
		{value: "RHeCos-1.1", text: "RHeCos-1.1"},
		{value: "RPL-1.1", text: "RPL-1.1"},
		{value: "RPL-1.5", text: "RPL-1.5"},
		{value: "RPSL-1.0", text: "RPSL-1.0"},
		{value: "RSA-MD", text: "RSA-MD"},
		{value: "RSCPL", text: "RSCPL"},
		{value: "Rdisc", text: "Rdisc"},
		{value: "Ruby", text: "Ruby"},
		{value: "SAX-PD", text: "SAX-PD"},
		{value: "SCEA", text: "SCEA"},
		{value: "SGI-B-1.0", text: "SGI-B-1.0"},
		{value: "SGI-B-1.1", text: "SGI-B-1.1"},
		{value: "SGI-B-2.0", text: "SGI-B-2.0"},
		{value: "SISSL", text: "SISSL"},
		{value: "SISSL-1.2", text: "SISSL-1.2"},
		{value: "SMLNJ", text: "SMLNJ"},
		{value: "SMPPL", text: "SMPPL"},
		{value: "SNIA", text: "SNIA"},
		{value: "SPL-1.0", text: "SPL-1.0"},
		{value: "SWL", text: "SWL"},
		{value: "Saxpath", text: "Saxpath"},
		{value: "Sendmail", text: "Sendmail"},
		{value: "SimPL-2.0", text: "SimPL-2.0"},
		{value: "Sleepycat", text: "Sleepycat"},
		{value: "Spencer-86", text: "Spencer-86"},
		{value: "Spencer-94", text: "Spencer-94"},
		{value: "Spencer-99", text: "Spencer-99"},
		{value: "SugarCRM-1.1.3", text: "SugarCRM-1.1.3"},
		{value: "TCL", text: "TCL"},
		{value: "TMate", text: "TMate"},
		{value: "TORQUE-1.1", text: "TORQUE-1.1"},
		{value: "TOSL", text: "TOSL"},
		{value: "UPL-1.0", text: "UPL-1.0"},
		{value: "Unicode-TO", text: "Unicode-TO"},
		{value: "Unlicense", text: "Unlicense"},
		{value: "VOSTROM", text: "VOSTROM"},
		{value: "VSL-1.0", text: "VSL-1.0"},
		{value: "Vim", text: "Vim"},
		{value: "W3C", text: "W3C"},
		{value: "W3C-19980720", text: "W3C-19980720"},
		{value: "WTFPL", text: "WTFPL"},
		{value: "Watcom-1.0", text: "Watcom-1.0"},
		{value: "Wsuipa", text: "Wsuipa"},
		{value: "X11", text: "X11"},
		{value: "XFree86-1.1", text: "XFree86-1.1"},
		{value: "XSkat", text: "XSkat"},
		{value: "Xerox", text: "Xerox"},
		{value: "Xnet", text: "Xnet"},
		{value: "YPL-1.0", text: "YPL-1.0"},
		{value: "YPL-1.1", text: "YPL-1.1"},
		{value: "ZPL-1.1", text: "ZPL-1.1"},
		{value: "ZPL-2.0", text: "ZPL-2.0"},
		{value: "ZPL-2.1", text: "ZPL-2.1"},
		{value: "Zed", text: "Zed"},
		{value: "Zend-2.0", text: "Zend-2.0"},
		{value: "Zimbra-1.3", text: "Zimbra-1.3"},
		{value: "Zimbra-1.4", text: "Zimbra-1.4"},
		{value: "Zlib", text: "Zlib"},
		{value: "bzip2-1.0.5", text: "bzip2-1.0.5"},
		{value: "bzip2-1.0.6", text: "bzip2-1.0.6"},
		{value: "curl", text: "curl"},
		{value: "diffmark", text: "diffmark"},
		{value: "dvipdfm", text: "dvipdfm"},
		{value: "eGenix", text: "eGenix"},
		{value: "gSOAP-1.3b", text: "gSOAP-1.3b"},
		{value: "gnuplot", text: "gnuplot"},
		{value: "iMatix", text: "iMatix"},
		{value: "libtiff", text: "libtiff"},
		{value: "mpich2", text: "mpich2"},
		{value: "psfrag", text: "psfrag"},
		{value: "psutils", text: "psutils"},
		{value: "xinetd", text: "xinetd"},
		{value: "xpp", text: "xpp"},
		{value: "zlib-acknowledgement", text: "zlib-acknowledgement"},
		{value: "Freeware", text: "Freeware"},
		{value: "Proprietary", text: "Proprietary"},
		{value: "Other", text: "Other"},
		{value: "Not licensed", text: "Not licensed"}
	]

	$scope.costOptions = [
		{value: "Free of charge", text: "Free of charge"},
		{value: "Free of charge (with restrictions)", text: "Free of charge (with restrictions)"},
		{value: "Commercial", text: "Commercial"}
	];

	$scope.languageOptions = [
		{value: "ActionScript", text: "ActionScript"},
		{value: "Ada", text: "Ada"},
		{value: "AppleScript", text: "AppleScript"},
		{value: "Assembly language", text: "Assembly language"},
		{value: "AWK", text: "AWK"},
		{value: "Bash", text: "Bash"},
		{value: "C", text: "C"},
		{value: "C#", text: "C#"},
		{value: "C++", text: "C++"},
		{value: "COBOL", text: "COBOL"},
		{value: "ColdFusion", text: "ColdFusion"},
		{value: "CWL", text: "CWL"},
		{value: "D", text: "D"},
		{value: "Delphi", text: "Delphi"},
		{value: "Dylan", text: "Dylan"},
		{value: "Eiffel", text: "Eiffel"},
		{value: "Elm", text: "Elm"},
		{value: "Forth", text: "Forth"},
		{value: "Fortran", text: "Fortran"},
		{value: "Groovy", text: "Groovy"},
		{value: "Haskell", text: "Haskell"},
		{value: "Icarus", text: "Icarus"},
		{value: "Java", text: "Java"},
		{value: "JavaScript", text: "JavaScript"},
		{value: "JSP", text: "JSP"},
		{value: "Julia", text: "Julia"},
		{value: "LabVIEW", text: "LabVIEW"},
		{value: "Lisp", text: "Lisp"},
		{value: "Lua", text: "Lua"},
		{value: "Maple", text: "Maple"},
		{value: "Mathematica", text: "Mathematica"},
		{value: "MATLAB", text: "MATLAB"},
		{value: "MLXTRAN", text: "MLXTRAN"},
		{value: "NMTRAN", text: "NMTRAN"},
		{value: "OCaml", text: "OCaml"},
		{value: "Pascal", text: "Pascal"},
		{value: "Perl", text: "Perl"},
		{value: "PHP", text: "PHP"},
		{value: "Prolog", text: "Prolog"},
		{value: "PyMOL", text: "PyMOL"},
		{value: "Python", text: "Python"},
		{value: "R", text: "R"},
		{value: "Racket", text: "Racket"},
		{value: "REXX", text: "REXX"},
		{value: "Ruby", text: "Ruby"},
		{value: "SAS", text: "SAS"},
		{value: "Scala", text: "Scala"},
		{value: "Scheme", text: "Scheme"},
		{value: "Shell", text: "Shell"},
		{value: "Smalltalk", text: "Smalltalk"},
		{value: "SQL", text: "SQL"},
		{value: "Turing", text: "Turing"},
		{value: "Verilog", text: "Verilog"},
		{value: "VHDL", text: "VHDL"},
		{value: "Visual Basic", text: "Visual Basic"},
		{value: "XAML", text: "XAML"},
		{value: "Other", text: "Other"}
	];

	$scope.platformOptions = [
		{value: "Mac", text: "Mac"},
		{value: "Linux", text: "Linux"},
		{value: "Windows", text: "Windows"},
	];

	$scope.accessibilityOptions = [
		{value: "Open access", text: "Open access"},
		{value: "Open access (with restrictions)", text: "Open access (with restrictions)"},
		{value: "Restricted access", text: "Restricted access"}
	];

	$scope.maturityOptions = [
		{value: "Emerging", text: "Emerging"},
		{value: "Mature", text: "Mature"},
		{value: "Legacy", text: "Legacy"}
	];

	$scope.toolTypeOptions = [
		{value: "Bioinformatics portal", text: "Bioinformatics portal"},
		{value: "Command-line tool", text: "Command-line tool"},
		{value: "Database portal", text: "Database portal"},
		{value: "Desktop application", text: "Desktop application"},
		{value: "Library", text: "Library"},
		{value: "Ontology", text: "Ontology"},
		{value: "Plug-in", text: "Plug-in"},
		{value: "Script", text: "Script"},
		{value: "SPARQL endpoint", text: "SPARQL endpoint"},
		{value: "Suite", text: "Suite"},
		{value: "Web application", text: "Web application"},
		{value: "Web API", text: "Web API"},
		{value: "Web service", text: "Web service"},
		{value: "Workbench", text: "Workbench"},
		{value: "Workflow", text: "Workflow"}
	];

	$scope.linkTypeOptions = [
		{value: "Discussion forum", text: "Discussion forum"},
		{value: "Galaxy service", text: "Galaxy service"},
		{value: "Helpdesk", text: "Helpdesk"},
		{value: "Issue tracker", text: "Issue tracker"},
		{value: "Mailing list", text: "Mailing list"},
		{value: "Mirror", text: "Mirror"},
		{value: "Repository", text: "Repository"},
		{value: "Service", text: "Service"},
		{value: "Social media", text: "Social media"},
		{value: "Software catalogue", text: "Software catalogue"},
		{value: "Technical monitoring", text: "Technical monitoring"},
		{value: "Other", text: "Other"}
	];

	$scope.downloadTypeOptions = [
		{value: "Downloads page", text: "Downloads page"},
		{value: "API specification", text: "API specification"},
		{value: "Biological data", text: "Biological data"},
		{value: "Binaries", text: "Binaries"},
		{value: "Command-line specification", text: "Command-line specification"},
		{value: "Container file", text: "Container file"},
		{value: "Icon", text: "Icon"},
		{value: "Screenshot", text: "Screenshot"},
		{value: "Software package", text: "Software package"},
		{value: "Source code", text: "Source code"},
		{value: "Test data", text: "Test data"},
		{value: "Test script", text: "Test script"},
		{value: "Tool wrapper (CWL)", text: "Tool wrapper (CWL)"},
		{value: "Tool wrapper (Galaxy)", text: "Tool wrapper (Galaxy)"},
		{value: "Tool wrapper (Taverna)", text: "Tool wrapper (Taverna)"},
		{value: "Tool wrapper (Other)", text: "Tool wrapper (Other)"},
		{value: "VM Image", text: "VM Image"},
		{value: "Other", text: "Other"}
	];

	$scope.documentationTypeOptions = [
		{value: "API documentation", text: "API documentation"},
		{value: "Citation instructions", text: "Citation instructions"},
		{value: "Code of conduct", text: "Code of conduct"},
		{value: "Command-line options", text: "Command-line options"},
		{value: "Contributions policy", text: "Contributions policy"},
		{value: "FAQ", text: "FAQ"},
		{value: "General", text: "General"},
		{value: "Governance", text: "Governance"},
		{value: "Installation instructions", text: "Installation instructions"},
		{value: "Quick start guide", text: "Quick start guide"},
		{value: "Release notes", text: "Release notes"},
		{value: "Terms of use", text: "Terms of use"},
		{value: "Training material", text: "Training material"},
		{value: "User manual", text: "User manual"},
		{value: "Other", text: "Other"}
	];

	$scope.publicationTypeOptions = [
		{value: "Primary", text: "Primary"},
		{value: "Benchmarking study", text: "Benchmarking study"},
		{value: "Method", text: "Method"},
		{value: "Usage", text: "Usage"},
		{value: "Review", text: "Review"},
		{value: "Other", text: "Other"}
	];

	$scope.entityTypeOptions = [
		{value: "Person", text: "Person"},
		{value: "Project", text: "Project"},
		{value: "Division", text: "Division"},
		{value: "Institute", text: "Institute"},
		{value: "Consortium", text: "Consortium"},
		{value: "Funding agency", text: "Funding agency"}
	];

	$scope.roleTypeOptions = [
		{value: "Primary contact", text: "Primary contact"},
		{value: "Contributor", text: "Contributor"},
		{value: "Developer", text: "Developer"},
		{value: "Documentor", text: "Documentor"},
		{value: "Maintainer", text: "Maintainer"},
		{value: "Provider", text: "Provider"},
		{value: "Support", text: "Support"}
	];

	$scope.elixirPlatformOptions = [
		{value: "Data", text: "Data"},
		{value: "Tools", text: "Tools"},
		{value: "Compute", text: "Compute"},
		{value: "Interoperability", text: "Interoperability"},
		{value: "Training", text: "Training"}
	];

	$scope.elixirNodeOptions = [
		{value: "Belgium", text: "Belgium"},
		{value: "Czech Republic", text: "Czech Republic"},
		{value: "Denmark", text: "Denmark"},
		{value: "EMBL", text: "EMBL"},
		{value: "Estonia", text: "Estonia"},
		{value: "Finland", text: "Finland"},
		{value: "France", text: "France"},
		{value: "Germany", text: "Germany"},
		{value: "Greece", text: "Greece"},
		{value: "Hungary", text: "Hungary"},
		{value: "Ireland", text: "Ireland"},
		{value: "Israel", text: "Israel"},
		{value: "Italy", text: "Italy"},
		{value: "Luxembourg", text: "Luxembourg"},
		{value: "Netherlands", text: "Netherlands"},
		{value: "Norway", text: "Norway"},
		{value: "Portugal", text: "Portugal"},
		{value: "Slovenia", text: "Slovenia"},
		{value: "Spain", text: "Spain"},
		{value: "Sweden", text: "Sweden"},
		{value: "Switzerland", text: "Switzerland"},
		{value: "UK", text: "UK"}
	];

	$scope.elixirCommunityOptions = [
		{value: "3D-BioInfo", text: "3D-BioInfo", link: "3d-bioinfo"},
		{value: "Federated Human Data", text: "Federated Human Data", link: "human-data"},
		{value: "Galaxy", text: "Galaxy", link: "galaxy"},
		{value: "Human Copy Number Variation", text: "Human Copy Number Variation", link: "hcnv"},
		{value: "Intrinsically Disordered Proteins", text: "Intrinsically Disordered Proteins", link: "intrinsically-disordered-proteins"},
		{value: "Marine Metagenomics", text: "Marine Metagenomics", link: "marine-metagenomics"},
		{value: "Metabolomics", text: "Metabolomics", link: "metabolomics"},
		{value: "Microbial Biotechnology", text: "Microbial Biotechnology", link: "microbial-biotechnology"},
		{value: "Plant Sciences", text: "Plant Sciences", link: "plant-sciences"},
		{value: "Proteomics", text: "Proteomics", link: "proteomics"},
		{value: "Rare Diseases", text: "Rare Diseases", link: "rare-diseases"}
		
	];

	$scope.otherIdTypeOptions = [
		{value: "doi", text: "doi"},
		{value: "rrid", text: "rrid"},
		{value: "cpe", text: "cpe"}
	];

	$scope.relationTypeOptions = [
		{value: "isNewVersionOf", text: "isNewVersionOf"},
		{value: "hasNewVersion", text: "hasNewVersion"},
		{value: "uses", text: "uses"},
		{value: "usedBy", text: "usedBy"},
		{value: "includes", text: "includes"},
		{value: "includedIn", text: "includedIn"}

	];

	$scope.confidenceOptions = [
		{value: "tool", text: "tool"},
		{value: "high", text: "high"},
		{value: "medium", text: "medium"},
		{value: "low", text: "low"},
		{value: "very low", text: "very low"},
	];


}])
.controller('ToolUpdateController', ['$scope', '$controller','$timeout','$state', '$stateParams', 'Tool', 'ToolUpdateValidator', 'Covid', 'CommunityCollection', function($scope, $controller, $timeout, $state, $stateParams, Tool, ToolUpdateValidator, Covid, CommunityCollection) {
	// inherit common controller
	$controller('ToolEditController', {$scope: $scope});

	// sets which controller is in use, so the HTML can adapt
	$scope.controller = 'update';

	// set the ID to not autoupdate when name is changed
	$scope.autoUpdateId = false;
	$scope.Covid = Covid;
	$scope.CommunityCollection = CommunityCollection;
	$scope.validateButtonClick = function() {
		$timeout(function() {
			$scope.sendResource(ToolUpdateValidator.update, $scope.validationProgress, false, 'update-validate');
		},100);
	}

	$scope.registerButtonClick = function() {
		$timeout(function() {
			if (confirm("Are you sure you want to update the resource? ")) {
				$scope.sendResource(Tool.update, $scope.savingProgress, false, 'update');
			}
		},100);
	}

	$scope.deleteButtonClick = function() {
		$timeout(function() {
			if (confirm("Are you sure you want to remove the resource? ")) {
				if (confirm("This will remove the resource and cannot be undone. Are you sure you want to continue? ")) {
					$scope.sendResource(Tool.remove, $scope.deletingProgress, true, 'delete');
				}
			}
		},100);
	}

	$scope.naviagateToTool = function(biotoolsID) {
		$timeout(function() {
			if (confirm("Make sure you save before navigating away! Are you sure you want to leave? ")) {
				$state.go('tool', {id: biotoolsID}, {reload: true});
			}
		},100);
	}


	// when a tool is being updated, display the current URL
	// $scope.$watch('software', function() {
	// 	$scope.setURL();
	// })

}])
.controller('ToolCreateController', ['$scope', '$controller', '$timeout', 'ToolListConnection', 'ToolCreateValidator', 'User', '$stateParams', 'Covid', 'CommunityCollection',function($scope, $controller, $timeout, ToolListConnection, ToolCreateValidator, User, $stateParams, Covid, CommunityCollection){
	// inherit common controller
	$controller('ToolEditController', {$scope: $scope});
	$scope.orderby = 'text';
	// sets which controller is in use, so the HTML can adapt
	$scope.controller = 'create';

	// initially set the ID to change automatically when name is modified
	$scope.biotoolsIDDisabled = true;
	$scope.editIdButtonText = 'Edit ID';
	$scope.Covid = Covid;
	$scope.CommunityCollection = CommunityCollection;
	// remove or replace all URL unsafe characters and set software.id
	$scope.makeIdURLSafe = function(value) {
		if (typeof value != 'undefined' && $scope.biotoolsIDDisabled) {
			$scope.software.biotoolsID = value.replace(/[^a-zA-Z0-9_~ .-]*/g,'').replace(/[ ]+/g, '_').toLowerCase();
		}else if ($scope.biotoolsIDDisabled){
			$scope.software.biotoolsID = "";
		}
		
	}

	$scope.editIdToggleButtonClick = function () {
		$scope.biotoolsIDDisabled = !$scope.biotoolsIDDisabled;
		$scope.makeIdURLSafe($scope.software.name);

		if ($scope.biotoolsIDDisabled){
			$scope.editIdButtonText = 'Edit ID';
		}else{
			$scope.editIdButtonText = 'From Name';
		}
	}

	

	$scope.validateButtonClick = function() {
		$timeout(function() {
			$scope.sendResource(ToolCreateValidator.save, $scope.validationProgress, false, 'create-validate');
		},100);
	}

	$scope.registerButtonClick = function() {
		if (confirm("Are you sure you want to save the resource?\nOnce saved the tool ID cannot be changed!")) {
			$timeout(function() {
				$scope.sendResource(ToolListConnection.save, $scope.savingProgress, false, 'create');
			},100);
		}
	}

	// TODO: needs to keep it DRY and in a service
	// function to clean all nulls from tool gotten from API
	function cleanNulls (object) {
		for (var key in object) {
			if (object[key] == null) {
				delete object[key]
			} else if (object[key].constructor === Array) {
				if (object[key].length == 0) {
					delete object[key]
				} else {
					for (var i in object[key]) {
						cleanNulls(object[key][i])
					}
				}
			} else if (typeof object[key] === 'object') {
				cleanNulls(object[key]);
			}
		}
	}

	if (typeof $stateParams.newVersionOf !== 'undefined') {
		$scope.newVersion = true;
		$scope.software = ToolLatest.get({id: $stateParams.newVersionOf}, function(response) {
			// success handler
			cleanNulls($scope.software);
			$scope.software.version = null;
		}, function(response) {
			// error handler
			if (response.status == 404) {
				$scope.notFound = true;
			}
		});
	} else {
		$scope.newVersion = false;
		// create the 'empty' software object
		$timeout(function() {
			$scope.software = {
				"owner": $scope.User.getUsername(),
				"name":"",
				"description":"",
				"homepage":""
				,
			};
		},100);
	}



}])
.controller('LoginController', ['$scope', '$state', 'djangoAuth', '$rootScope',function($scope, $state, djangoAuth, $rootScope) {
	$scope.credentials = {};

	$scope.loginButtonClick = function() {
		djangoAuth.login($scope.credentials.username, $scope.credentials.password)
		.then(function (response) {
			// go to states set before redirection to login
			if(typeof $rootScope.toState == 'undefined' || /signup/.test($rootScope.toState.name) || /reset-password/.test($rootScope.toState.name)) {
				$state.go('search');
			} else {
				$state.go($rootScope.toState.name, $rootScope.toStateParams);
			}
		}, function (response) {
			$scope.loginErrors = response.general_errors;
		});
	}

	// clean errors when credentials are changed
	$scope.$watch('credentials', function() {
		if ($scope.loginErrors) {
			$scope.loginErrors.pop();
			delete $scope.loginErrors;
		}
	}, true);
}])
.controller('SignupController', ['$scope', '$state', 'djangoAuth', '$rootScope', '$timeout', function($scope, $state, djangoAuth, $rootScope, $timeout) {
	$scope.credentials = {};
	$scope.error_message = {};
	$scope.error_message.username = '';
	$scope.error_message.email = '';
	$scope.error_message.creation = '';

	// check if username is taken
	var initializing_username = true;
	$scope.$watch('credentials.username', function(newValue, oldValue, scope) {
		if (!initializing_username) {
			$scope.error_message.username = '';
			djangoAuth.register($scope.credentials.username, null, null, null, null)
			.then(function (response) {
				// success never happens since parameters are missing
			}, function (response) {
				if (response.hasOwnProperty('username')) {
					$scope.error_message.username = 'Username is already taken.';
				}
			});
		} else {
			initializing_username = false;
		}
	});

	// check if email is taken
	var initializing_email = true;
	$scope.$watch('credentials.email', function(newValue, oldValue, scope) {
		if (!initializing_email) {
			$scope.error_message.email = '';
			djangoAuth.register(null, null, null, $scope.credentials.email, null)
			.then(function (response) {
				// success never happens since parameters are missing
			}, function (response) {
				if (response.hasOwnProperty('email')) {
					$scope.error_message.email = 'Email is invalid or already taken.';
				}
			});
		} else {
			initializing_email = false;
		}
	});

	$scope.signupButtonClick = function() {
		$scope.loading = true;
		$timeout(function() {
			djangoAuth.register($scope.credentials.username, $scope.credentials.password, $scope.credentials.password, $scope.credentials.email, null)
			.then(function (response) {
				$state.go('signup.success');
				$scope.loading = false;
			}, function (response) {
				$scope.error_message.email = response.email.join();
				$scope.error_message.username = response.username.join();
				$scope.error_message.creation = response.message;
				$scope.loading = false;
			});
		},100);
	}
}])
.controller('SignupVerifyEmailKeyController', ['$scope', '$state', '$stateParams', 'djangoAuth', function($scope, $state, $stateParams, djangoAuth) {
	$scope.error_message = '';

	djangoAuth.verify($stateParams.key)
	.then(function (response) {
		$state.go('signup.verify-email.success');
	}, function (response) {
		$scope.error_message = response.message;
	});
}])
.controller('ResetPasswordController', ['$scope', '$state', '$stateParams', 'djangoAuth', function($scope, $state, $stateParams, djangoAuth) {
	$scope.credentials = {};
	$scope.error_message = '';
	$scope.success_message = '';

	$scope.loading = false;
	$scope.resetButtonClick = function() {
		$scope.error_message = '';
		$scope.success_message = '';
		$scope.loading = true;
		djangoAuth.resetPassword($scope.credentials.email)
		.then(function (response) {
			$scope.success_message = response.success;
			$scope.loading = false;
		}, function (response) {
			$scope.error_message = response;
			$scope.loading = false;
		});
	}
}])
.controller('ResetPasswordConfirmController', ['$scope', '$state', '$stateParams', 'djangoAuth', function($scope, $state, $stateParams, djangoAuth) {
	$scope.credentials = {};
	$scope.error_message = false;
	var uid = $stateParams.uid;
	var token = $stateParams.token;

	$scope.loading = false;
	$scope.resetButtonClick = function() {
		$scope.error_message = false;
		$scope.loading = true;
		djangoAuth.confirmReset(uid, token, $scope.credentials.password, $scope.credentials.password)
		.then(function (response) {
			$state.go('reset-password.confirm.success');
			$scope.loading = false;
		}, function (response) {
			$scope.error_message = true;
			$scope.loading = false;
		});
	}
}]);

function EdamModalCtrl($modalInstance, edam, onto, type, suggestions) {
	var vm = this;
	vm.data = angular.copy(edam);
	vm.onto = onto;
	vm.self = $modalInstance;
	vm.type = type;
	vm.suggestions = suggestions;

	vm.saveData = function () {
		if (isEmptyObject(vm.data)) {
			$modalInstance.dismiss('cancel');
			return;
		}
		$modalInstance.close(vm.data);
	};

	vm.apply_suggestion = function (suggestion) {
		vm.predicate = suggestion.term;
	};

	vm.customOrder = function (node) {
		if (!vm.suggestions) {
			return node.text.toLowerCase();
		}

		var isSuggested = containsSuggestion(node);
		return (isSuggested ? '0' : '1') + node.text.toLowerCase();
	};

	vm.isSuggested = function (node) {
		return vm.suggestions && containsSuggestion(node);
	};

	vm.cancel = function () {
		$modalInstance.dismiss('cancel');
	};

	function isEmptyObject(obj) {
		return angular.equals(obj, {});
	}

	function containsSuggestion(node) {
		return vm.suggestions.some(function (suggestion) {
			return suggestion.term === node.text;
		});
	}
}

'use strict';

/* Directives */

angular.module('elixir_front.directives', [])
.directive('toolList', ['ToolList', 'Highlighting', 'Covid', function(ToolList, Highlighting, Covid) {
	return {
		restrict: 'A',
		templateUrl: 'partials/directives/toolList.html',
		link: function(scope, element, attrs) {
			// reference the ToolList in the scope
			scope.ToolList = ToolList;
			// reference Highlighting in the scope
			scope.Highlighting = Highlighting;
			scope.Covid = Covid;
		}
	}
}])
.directive('showMore',
	[function(){
		return {
			templateUrl: 'showMore.html',
			restrict: 'A',
			transclude: true,
			scope:{
				'showMoreHeight': '@'
			},
			controller: ['$scope', '$element', '$interval', function($scope, $element, $interval) {

				$scope.expanded = false;

				$interval(function(){
					renderStyles();
				}, 300);

				$scope.expandable = false;
				function renderStyles(){
					if($element.height() >= $scope.showMoreHeight && $scope.expanded === false){
						$scope.expandable = true;
					}
				}

				$scope.showLessStyle = {
					'max-height': $scope.showMoreHeight + 'px',
					'overflow': 'hidden'
				};

			}]
		};
	}])
.directive('toolListTable', ['ToolList', 'ToolTableDataSource', 'Highlighting', function(ToolList, ToolTableDataSource, Highlighting) {
	return {
		restrict: 'A',
		templateUrl: 'partials/directives/toolListTable.html',
		link: function(scope, element, attrs) {
			// reference Highlighting in the scope
			scope.Highlighting = Highlighting;
			scope.ToolTableDataSource = ToolTableDataSource;
		}
	}
}])
.directive('toolSorter', ['ToolList', '$state','$stateParams', '$timeout', 'ToolSorter', 'Query', '$rootScope', function(ToolList, $state, $stateParams, $timeout, ToolSorter, Query, $rootScope) {
	return {
		restrict: 'A',
		templateUrl: 'partials/directives/sorter.html',
		link: function(scope, element, attrs) {
			// reference the ToolPaginator in the scope
			scope.ToolSorter = ToolSorter;

			// put sorting attributes in the url
			scope.addToURL = function() {
				var params = $stateParams;
				// set the sorting url parameters
				if (ToolSorter.sortBy.attrName == 'lastUpdate' && ToolSorter.order == true) {
					// set defaults as null
					params['sort'] = null;
					params['ord'] = null;
				} else {
					params['sort'] = ToolSorter.sortBy.attrName;
					params['ord'] = ToolSorter.order ? 'desc' : 'asc';
				}
				$state.transitionTo('search', params, { notify: false });
			}

			// ran on changing the dropdown value
			scope.sortingChangedByDropdown = function() {
				scope.addToURL();
				$timeout( function() {
					ToolList.refresh();
				});
			}

			scope.validateSelectedSortOption = function() {
  				if (Query.current.length > 0) {
					ToolSorter.addScore();
				} else {
					ToolSorter.removeScore();
				}
				ToolSorter.setSortOption($stateParams['sort']);
  			}

			// read current sorting attribute from url
			if ($stateParams['sort'] != null) {
				if ($stateParams['sort'] == 'score') {
					ToolSorter.addScore();
				}
				ToolSorter.sortBy = ToolSorter.list[_.findIndex(ToolSorter.list, {"attrName": $stateParams['sort']}) || 0];
			}
			// read current sorting order from url
			if ($stateParams['ord'] != null) {
				if ($stateParams['ord'] == 'desc') {
					ToolSorter.order = true;
				} else if($stateParams['ord'] == 'asc'){
					ToolSorter.order = false;
				}
			}

			$rootScope.$on('$stateChangeSuccess', function(event, toState, toStateParams, fromState, fromStateParams) {
				scope.validateSelectedSortOption();
			});

			$rootScope.$on('search-bar-tags-changed', function handler() {
    			scope.validateSelectedSortOption();
  			});


		}
	}
}])
.directive('displayModeSelector', ['ToolList', '$state','$stateParams', '$timeout', 'DisplayModeSelector', function(ToolList, $state, $stateParams, $timeout, DisplayModeSelector) {
	return {
		restrict: 'A',
		templateUrl: 'partials/directives/displaySelector.html',
		link: function(scope, element, attrs) {
			scope.DisplayModeSelector = DisplayModeSelector;

			// put sorting attributes in the url
			scope.modeChanged = function() {
				$timeout( function() {
					ToolList.refresh();
				});
			}
		}
	}
}])
.directive('toolPaginator', ['ToolList', '$state','$stateParams', 'Query', '$timeout', 'ToolPaginator', function(ToolList, $state, $stateParams, Query, $timeout, ToolPaginator) {
	return {
		restrict: 'A',
		template: '<uib-pagination style="margin-bottom:25px; margin-top:25px;" total-items="ToolList.count" ng-model="ToolPaginator.currentPage" items-per-page="ToolPaginator.pageSize" max-size="ToolPaginator.maxSize" ng-change="pageChanged()" class="pagination-sm pagination-top" ng-disabled="ToolList.loading"></uib-pagination>',
		link: function(scope, element, attrs) {
			// reference the Query in the scope
			scope.Query = Query;
			// reference the ToolPaginator in the scope
			scope.ToolPaginator = ToolPaginator;

			// read current page from url
			if ($stateParams['page'] != null) {
				ToolPaginator.currentPage = parseInt($stateParams['page']);
			} else {
				ToolPaginator.currentPage = 1;
			}

			// when page changes, store the new page in the url and refresh the list of tools
			scope.pageChanged = function() {
				var params = $stateParams;
				$timeout( function() {
					// set the 'page' URL parameter according to currentPage
					params['page'] = ToolPaginator.currentPage != 1 ? ToolPaginator.currentPage : null;
					$state.transitionTo('search', params, { notify: false });
					ToolList.refresh();
				});
			}

			// riddiculous hax, otherwise it keeps changing to 1
			var initializing = true;
			scope.$watch('ToolPaginator.currentPage', function(newVal, oldVal) {
				if (initializing) {
					if (newVal != oldVal && newVal == 1) {ToolPaginator.currentPage = oldVal};
					$timeout(function() { initializing = false; });
				}
			});

			// reset page to 1 when query changes
			scope.$watch('Query.current', function() {
				ToolPaginator.currentPage = 1;
			}, true);

		}
	}
}])

// inserts a link to a publication resolving page, depending on the type of publication
.directive("insertPublicationLink", function($compile){
	return {
		restrict: 'A',
		scope: {
			publication: '='
		},
		compile: function CompilingFunction($templateElement, $templateAttributes) {
			return function LinkingFunction($scope, $element, $attrs) {
				var html = '';
				// PUBMED
				if (/^\d{7,8}$/.test($scope.publication)) {
					html = '<span>PUBMED:</span> <a href="http://www.ncbi.nlm.nih.gov/pubmed/' + $scope.publication + '">' + $scope.publication + '</a>';
				// PMC
			} else if (/^PMC\d{6,8}$/.test($scope.publication)) {
				html = '<span>PMC:</span> <a href="http://www.ncbi.nlm.nih.gov/pmc/' + $scope.publication + '">' + $scope.publication + '</a>';
				// DOI
			} else if (/^(doi:)?\d{2}.\d{4}/.test($scope.publication)) {
				var publication = $scope.publication.replace('doi:','');
				html = '<span>DOI:</span> <a href="https://dx.doi.org/' + publication + '">' + publication + '</a>';
			}
			var e = $compile(html)($scope);
			$element.replaceWith(e);
		};
	}
}
})
// inserts a link to a publication resolving page, depending on the type of publication
.directive("insertPublicationLinkIcon", function($compile){
	return {
		restrict: 'A',
		scope: {
			publication: '='
		},
		compile: function CompilingFunction($templateElement, $templateAttributes) {
			return function LinkingFunction($scope, $element, $attrs) {
				var html = '';
				// PUBMED
				if (/^\d{7,8}$/.test($scope.publication)) {
					html = '<a href="http://www.ncbi.nlm.nih.gov/pubmed/' + $scope.publication + '"><i class="fa fa-external-link" aria-hidden="true" uib-tooltip="PUBMED" tooltip-append-to-body="true"></i></a>';
				// PMC
			} else if (/^PMC\d{6,8}$/.test($scope.publication)) {
				html = '<a href="http://www.ncbi.nlm.nih.gov/pmc/' + $scope.publication + '"><i class="fa fa-external-link" aria-hidden="true" uib-tooltip="PMC" tooltip-append-to-body="true"></i></a>';
				// DOI
			} else if (/^(doi:)?\d{2}.\d{4}/.test($scope.publication)) {
				var publication = $scope.publication.replace('doi:','');
				html = '<a href="https://dx.doi.org/' + publication + '"><i class="fa fa-external-link" aria-hidden="true" uib-tooltip="DOI" tooltip-append-to-body="true"></i></a>';
			}
			var e = $compile(html)($scope);
			$element.replaceWith(e);
		};
	}
}
})
// makes this element focused
.directive('focus', function () {
	return {
		restrict: 'A',
		link: function(scope, iElm, iAttrs, controller) {
			iElm[0].focus();
		}
	}
})
// creates an animated spinner
.directive('spinner', function() {
	return {
		restrict: 'A',
		replace: 'true',
		template: '<div class="adjust"><div class="spinner"></div></div>'

	}
})
// creates a resource not found message
.directive('resourceNotFoundDialog', function() {
	return {
		restrict: 'A',
		replace: 'true',
		template: '<div class="col-md-12 info-dialog-background info-dialog info-dialog-text">We\'re sorry but we couldn\'t find what you were looking for. You can try searching for the resource you need <a ui-sref="search()">here</a>.</div>'
	}
})
// creates an error message
.directive('errorDialog', function() {
	return {
		restrict: 'A',
		replace: true,
		template: function(elem, attr){
			return '<div class="col-md-offset-2 col-md-8 bs-callout bs-callout-danger" style="margin-top: 80px;"><h4><i class="fa fa-exclamation-circle" aria-hidden="true"></i> Error {{' + attr.errorcode + '}}</h4>{{' + attr.errormessage + '}}</div>'
		},
		transclude: true
	}
})
// make this element ignore pressing the 'Enter' key
.directive('ignoreEnter', function() {
	return function (scope, element, attrs) {
		element.bind("keydown keypress", function (event) {
			if (event.which === 13) {
				event.preventDefault();
			}
		});
	}
})
.directive('validateEditResourceField', function () {
	return {
		restrict: 'A',
		require: ['^form','ngModel'],
		link: function (scope, element, attrs, ctrls) {
			var ngForm = ctrls[0];
			var ngModel = ctrls[1];
			// Initialization - create the data path based on ng-model path.
			var dataPath = attrs.ngModel.replace("software.", "").replace("$parent.$index", attrs.parentIndex).replace("$index", attrs.index).replace("[", ".").replace("]", "").split(".");
			// Remove errors once values have been edited.
			ngModel.$parsers.push(function(value) {
				_.set(scope.registrationErrorPayload, dataPath, null);
				ngModel.errorMessages = [];
				ngModel.$setValidity('server_validation_passed', true);
				return value;
			});
			ngModel.$viewChangeListeners.push(function() {
				// Prevent non-mandatory fields from becoming mandatory,
				// by assigning empty strings to the keys in the object to be
				// sent to the server.
				var value = _.get(scope.software, dataPath);
				if (value === "") {
					_.unset(scope.software, dataPath);
				}
			});
			// Observe for changes in the server-side validation
			// of a resource appeared - i.e. user pressed validate in resource edit
			scope.$watch('registrationErrorPayload', function(date) {
				// Find the error and set the input validity based on the results.
				var error = _.result(scope.registrationErrorPayload, dataPath);
				if (_.isEmpty(error) == false) {
					// Error exist - server validation failed.
					ngModel.$setValidity('server_validation_passed', false);
					ngModel.errorMessages = error;
				}
				else {
					// Error does not exist - server validation passed.
					ngModel.$setValidity('server_validation_passed', true);
					ngModel.errorMessages = [];
				}
				// Find the error and set the form validity based on the results.
				var formError = extractFormErrors();
				// There are errors in the form.
				if (formError.length > 0) {
					ngForm.$setValidity('server_validation_passed', false);
					ngForm.errorMessages = _.union(ngForm.errorMessages, formError);
				}
				else {
					ngForm.$setValidity('server_validation_passed', true);
					ngForm.errorMessages = [];
				}
			});
			var extractFormErrors = function() {
				var formErrors = [];
				for (var i = 1; i < dataPath.length; i++) {
					var subDataPath = dataPath.slice(0,i);
					subDataPath.push("general_errors");
					var error = _.result(scope.registrationErrorPayload, subDataPath);
					if (_.isEmpty(error) == false) {
						formErrors = formErrors.concat(error);
					}
				}
				return formErrors;
			}
		}
	}
})
.directive("dividerLabel", function(){
	return {
		restrict: 'A',
		transclude: true,
		template: function(elem, attr){
			var callout = 'class="tool-page-diver-label"';
			return callout;
		},
		replace: true
	};
})
// creates an animated small spinner
.directive('smallSpinner', function() {
	return {
		restrict: 'A',
		replace: 'true',
		template: '<div style="text-align:center; color: #7f7f7f; font-size: 12px;"><i class="fa fa-circle-o-notch fa-spin"></i> Processing...</div>'
	}
})
.directive('largeSpinner', function() {
	return {
		restrict: 'A',
		replace: 'true',
		template: '<div style="text-align:center; color: #cccccc; font-size: 60px;"><i class="fa fa-circle-o-notch fa-spin"></i></div>'
	}
});




'use strict';

/* Filters */

angular.module('elixir_front.filters', []).
// necessary for paging
filter('startFrom', function() {
	return function(input, start) {
			start = +start; //parse to int
			if (input) {
				return input.slice(start);
			} else {
				return;
			}
	}
}).
// filtering of a list of object by an object - used in filters in query interface
filter('filterByObject', function($filter) {
	return function (list, filter) {
		// recursively go through list entry and filter objects to find a match
		function filterMatch(entry, filter) {
			if (typeof filter === 'undefined') {
				return true;
			} else if (entry == null) {
				return false;
			}
			var result = false;
			for (var _key in filter) {
				result = false;
				// return true if filter empty
				if (typeof filter[_key] === 'undefined' || filter[_key] == '') {
					result = true;
				// skip if entry does not have the key from the filter
				} else if (typeof entry[_key] === 'undefined') {
					result = false;
				// if filter is not a deeper object nor an array just perform normal comparison
				} else if (typeof filter[_key] !== 'object') {
					// if entry is not a deeper object nor an array just perform normal comparison
					if (typeof entry[_key] !== 'object') {
						result = entry[_key].toLowerCase().indexOf(filter[_key].toLowerCase()) > -1
					// if entry is a deeper object perform deeper checking
					} else {
						// if entry is an array
						if (Array.isArray(entry[_key])) {
							// need a boolean to store whether any of the former array elements matched the filter; need this otherwise result could be overwritten with latter elements, even if the former ones matched
							var result_inner = false;
							// go through the whole entry array and check each element against the filter
							for (var j = 0; j < entry[_key].length; j++) {
								// if entry is a string, just perform normal comparison
								if (typeof entry[_key][j] == "string") {
									result_inner = entry[_key][j].toLowerCase().indexOf(filter[_key].toLowerCase()) > -1
								// if entry is an ontology only compare the term and not the URI to the filter
								} else if ('term' in entry[_key][j]) {
									result_inner = entry[_key][j].term.toLowerCase().indexOf(filter[_key].toLowerCase()) > -1
								// if entry is a different object then search for filter within it
								} else {
									// need to go through all properties of an entry to see if any matches are found
									for (var property in entry[_key][j]) {
										if(entry[_key][j].hasOwnProperty(property)) {
											if (JSON.stringify(entry[_key][j][property]).toLowerCase().indexOf(filter[_key].toLowerCase()) > -1) {
												result_inner = true;
												break;
											}
										}
									}
								}
								// if any of array elements matches, set result to true; this way even if the former elements match, the unmatching latter ones will not overwrite result
								if (result_inner) {
									result = true;
									break;
								}
							}
						// if entry is not an array
						} else {
							// if entry is an ontology only compare the term and not the URI to the filter
							if ('term' in entry[_key]) {
								result = entry[_key].term.toLowerCase().indexOf(filter[_key].toLowerCase()) > -1
							// if entry is a different object then search for filter within it
							} else {
								// need to go through all properties of an entry to see if any matches are found
								for (var property in entry[_key]) {
									if(entry[_key].hasOwnProperty(property)) {
										if (JSON.stringify(entry[_key][property]).toLowerCase().indexOf(filter[_key].toLowerCase()) > -1) {
											result = true;
											break;
										}
									}
								}
							}
						}
					}
				// if entry is an array and not an object
				} else if (Array.isArray(entry[_key])) {
					// go through the array and run the filter recursively
					for (var j = 0; j < entry[_key].length; j++) {
						if (filterMatch(entry[_key][j], filter[_key])) {
							result = true;
							break;
						}
					}
				} else {
					// if filter is a deeper object, call the same function recursively
					result = filterMatch(entry[_key], filter[_key]);
				}
				// if one of the filters didn't match return false
				if (!result) {
					return false;		
				}
			}
			// return true only if all the elements matched
			return true;
		}
		
		// list of matching elements
		var return_list = [];
		if (list) {
			// go through all elements
			for (var i=0; i < list.length; i++) {
				// add element to list if filter matches
				if ( filterMatch(list[i], filter) == true ) {
					return_list.push(list[i]);   
				}
			}
		}
		return return_list;
	};
}).
// query fuzzy matching which produces the relevance score
filter('filterQuery', function() {
	return function (list, filter) {
		// if filter empty return all resources
		if (filter == "" || filter == null) {
			return list;
		}

		// list of matching elements
		var return_list = [];
		if (list && list.length > 0) {
			// go through all elements
			for (var i=0; i < list.length; i++) {
				if (!_.isEmpty(list[i])){
					// calculate the fuzzy score of some of the attributes of each resource vs the filter
					var search_score = (list[i].name + " " + list[i].description + " " + list[i].topic + " " + list[i].function + " " + list[i].affiliation).score(filter);
					// if there is a non-zero match
					if ( search_score > 0 ) {
						// invert the score for sorting purposes
						list[i].search_score = 1.0 - search_score;
						return_list.push(list[i]);   
					}
				}
			}
		}
		return return_list;
	}
}).
// filter that highlights matches
filter('highlight', function($sce) {
	return function(str, termsToHighlight) {
		if (str && termsToHighlight.length > 0) {
			// Sort terms by length
			termsToHighlight.sort(function(a, b) {
				return b.length - a.length;
			});
			// Regex to simultaneously replace terms
			var regex = new RegExp('(' + termsToHighlight.join('|') + ')', 'gi');
			return $sce.trustAsHtml(str.replace(regex, '<span class="highlightedTerm">$&</span>'));
		} else {
			return str;
		}
	};
});
// Controllers
angular.module('elixir_front.controllers').controller('LoginMangerController', ['$scope', '$uibModal', '$rootScope', '$state', function($scope, $uibModal, $rootScope, $state) {
	var vm = this;

	vm.openLoginModal = function() {
		$uibModal.open({
			templateUrl: 'partials/modals/loginModal.html',
			controller: ['$uibModalInstance', 'djangoAuth', '$rootScope', '$state', LoginModalController],
			controllerAs: 'vm',
			windowClass: 'login-modal-window'
		});
	};
}]);

function LoginModalController($uibModalInstance, djangoAuth, $rootScope, $state) {
	var vm = this;
	vm.error = {};

	vm.loginButtonPressed = function(username, password) {
		vm.error.username = "";
		vm.error.password = "";
		vm.error.general = [];
		if (!username && !password) {
			vm.error.username = "Username is required";
			vm.error.password = "Password is required";
			vm.error.general = ["Username and password are required"];
		}
		else if (!username) {
			vm.error.username = "Username is required";
			vm.error.general = ["Username is required"];
		}
		else if (!password) {
			vm.error.password = "Password is required";
			vm.error.general = ["Password is required"];
		}
		else {
			djangoAuth.login(username, password).then(function (response) {
			// go to states set before redirection to login
			if(typeof $rootScope.toState == 'undefined' || /signup/.test($rootScope.toState.name) || /reset-password/.test($rootScope.toState.name)) {
				$state.go('search');
			} else {
				$state.go($rootScope.toState.name, $rootScope.toStateParams);
			}
			$uibModalInstance.close();
		}, function (response) {
			vm.error.general = response.general_errors;
		});
		}
	}

	vm.registerButtonPressed = function() {
		$uibModalInstance.close();
		$state.go('signup');
	}

	vm.forgotButtonPressed = function() {
		$uibModalInstance.close();
		$state.go('reset-password');
	}
}

// Controllers
angular.module('elixir_front.controllers').controller('PermissionsController', ['$scope', 'UserSuggestionsProvider', function($scope, UserSuggestionsProvider) {
	var vm = this;

	// Typeahead Support
	$scope.userSuggestions = function(prefix) {
		return UserSuggestionsProvider.getSuggestions(prefix).then(function(data) {
			var suggestions = _.map(data, function(obj){
				return obj.username;
			});
			return _.difference(suggestions, $scope.software.editPermission.authors);
		});
	};

	$scope.userSelected = function($item, $model, $label) {
		// Initialize authors if not present.
		if ($scope.software.editPermission.authors == undefined) {
			$scope.software.editPermission.authors = [];
		}
		// Clear the input field on selection.
		$scope.userSuggestion = '';
		$scope.software.editPermission.authors.push($model);
	};

	$scope.isSoftwareOwner = function() {
		if ($scope.software.owner == $scope.User.getUsername()) {
			return true;
		}
		return false;
	}

	$scope.deleteUser = function(index) {
		$scope.software.editPermission.authors.splice(index, 1);
	}
}]);

// Services and Factories
var elixir_front = angular.module('elixir_front');
elixir_front.factory('UserSuggestionsProvider', ['$http', function ($http) {
	return {
		getSuggestions: function(prefix) {
			return $http({
				method: 'GET',
				url: '/api/user-list',
				params: {term: prefix}
			}).then(function successCallback(response) {
				return response.data;
			}, function errorCallback(response) {
				return {};
			})
		}
	};
}]);

// Controllers
angular.module('elixir_front.controllers').controller('RequestsController', ['$scope', 'ResourceRequestProvider', 'User', function($scope, ResourceRequestProvider, User) {
	var vm = this;
	$scope.requests = {};
	$scope.received = [];
	$scope.sent = [];
	$scope.loading = true;
	$scope.error = {}
	$scope.error.status = 0;
	$scope.error.message = "";
	$scope.filters = {};
	$scope.filters.showCompletedReceived = false;
	$scope.filters.showCompletedSent = false;

	// Data feteching
	vm.loadRequests = function($item, $model, $label) {
		$scope.loading = true;
		ResourceRequestProvider.getRequests().then(function successCallback(response) {
			$scope.requests = response.data.requests;
			$scope.filterSentRequests();
			$scope.filterReceivedRequests();
			$scope.loading = false;
		}, function errorCallback(response) {
			$scope.error.status = response.status;
			$scope.error.message = "There was an error communicating with the server. Try refreshing this website.";
			$scope.loading = false;
		});
	};	

	$scope.filterSentRequests = function() {
		if ($scope.filters.showCompletedSent == false) {
			$scope.sent = $scope.requests.sent.filter(vm.checkIfNotCompleted);
		}
		else {
			$scope.sent = $scope.requests.sent;
		}
	}

	$scope.filterReceivedRequests = function() {
		if ($scope.filters.showCompletedReceived == false) {
			$scope.received = $scope.requests.received.filter(vm.checkIfNotCompleted);
		}
		else {
			$scope.received = $scope.requests.received;
		}
	}

	//Operations
	vm.checkIfNotCompleted = function(request) {
		return !request.completed;
	}

	vm.requestsAffectedByAcceptingRequest = function(request) {
		// Accept ownership for not own request.
		if (request.type == "ownership" && request.username != User.current.username) {
			var affectedRequests = [];
			for (var index = 0; index < $scope.requests.received.length; ++index) {
				var checkRequest = $scope.requests.received[index];
				if (checkRequest.completed == false && checkRequest.requestId != request.requestId && checkRequest.resourceId == request.resourceId) {
					affectedRequests.push(checkRequest);
				}
			}
			return affectedRequests;
		}
		return []; 
	}

	$scope.typeDescription = function(type) {
		if (type == "editing") {
			return "Editing rights";
		}
		return "Resource ownership";
	}

	$scope.acceptRequest = function(request) {
		var affectedRequests = vm.requestsAffectedByAcceptingRequest(request);
		var resourceIndex = $scope.requests.received.indexOf(request);
		if (affectedRequests.length == 0) {
			vm.processAcceptRequest(resourceIndex, request, affectedRequests);
		}
		else {
			if (confirm("Are you sure you want to accept this request? " + affectedRequests.length + " of the exisitng requests will be sent to the new owner.")) {
				vm.processAcceptRequest(resourceIndex, request, affectedRequests);
			}
		}
	}	

	vm.processAcceptRequest = function(index, request, affectedRequests) {
		var resourceIndex = index;
		$scope.requests.received[resourceIndex].processing = true
		request.processing = false
		ResourceRequestProvider.acceptRequest(request.requestId).then(function successCallback(response) {
			$scope.requests.received[resourceIndex].processing = false
			$scope.requests.received[resourceIndex].completed = true
			$scope.requests.received[resourceIndex].accepted = true
			$scope.requests.received = _.difference($scope.requests.received, affectedRequests);
			$scope.received = _.difference($scope.received, affectedRequests); 
			request.processing = false
			request.completed = true
			request.accepted = true
			User.current.requests_count = User.current.requests_count - 1 - affectedRequests.length;
		}, function errorCallback(response) {
			vm.loadRequests();
		});
	}

	$scope.declineRequest = function(request) {
		var resourceIndex = $scope.requests.received.indexOf(request);
		request.processing = false
		$scope.requests.received[resourceIndex].processing = true
		ResourceRequestProvider.declineRequest(request.requestId).then(function successCallback(response) {
			$scope.requests.received[resourceIndex].processing = false
			$scope.requests.received[resourceIndex].completed = true
			$scope.requests.received[resourceIndex].accepted = false
			request.processing = false
			request.completed = true
			request.accepted = false
			User.current.requests_count = User.current.requests_count - 1;
		}, function errorCallback(response) {
			vm.loadRequests();
		});
	}

	// Initialization
	vm.loadRequests();
}]);

// Services and Factories
var elixir_front = angular.module('elixir_front');
elixir_front.factory('ResourceRequestProvider', ['$http', function ($http) {
	return {
		getRequests: function() {
			return $http({
				method: 'GET',
				url: '/api/request',
				params: {}
			})
		},
		acceptRequest: function(requestId) {
			return $http({
				method: 'POST',
				url: '/api/request/conclude',
				data: {'requestId': requestId, accept: true}
			})
		},
		declineRequest: function(requestId) {
			return $http({
				method: 'POST',
				url: '/api/request/conclude',
				data: {'requestId': requestId, accept: false}
			})
		},
		requestOwnership: function(resourceId) {
			return $http({
				method: 'PUT',
				url: '/api/request',
				data: {'resourceId': resourceId, type: 'ownership'}
			})
		},
		requestEditingRights: function(resourceId) {
			return $http({
				method: 'PUT',
				url: '/api/request',
				data: {'resourceId': resourceId, type: 'editing'}
			})
		}
	};
}]);
'use strict';

/* Services */

angular.module('elixir_front.services', [])
.service('Alert', function(){
	this.list = [];
	this.add = function(_message, _type) {
		this.list.push({msg: _message, type: _type, ttl:2});
	};
	this.remove = function(_index) {
		this.list.splice(_index, 1);
	}
})
.service('User', [function(){
	this.current = {};
	return {
		isLoggedIn: function () {
			return this.authenticated == true;                   
		},
		getUsername: function () {
			if (!_.isEmpty(this.current)) {
				return this.current.username;
			}
		},
		isSuperuser: function () {
			if (!_.isEmpty(this.current)) {
				return this.current.is_superuser;
			}
		},

	}
}])
.service('Query', [function(){
	this.current = [];
}])
.service('DomainConnection', ['$resource', function($resource){
	return $resource('/api/d/', null, {
		'query': {
			isArray: true,
			method:'GET'
		},
		'create': {
			method:'POST'
		}
	})
}])
.service('DomainDetailConnection', ['$resource', function($resource){
	return $resource('/api/d/:domain', {'domain': '@domain'}, {
		'query': {
			isArray:false,
			method:'GET'
		},
		'update': {
			method:'PUT'
		},
		'delete': {
			method:'DELETE'
		}
	})
}])
.service('Domain', ['DomainDetailConnection', function(DomainDetailConnection){
	var _this = this;
	this.current = {};
	this.loaded = false;
	this.set = function(domain) {
		_this.current = domain;
	}
	this.load = function(domain) {
		if (typeof domain != 'undefined') {
			var response = DomainDetailConnection.query({'domain':domain}, function(response) {
				_this.set(response.data);
				_this.loaded = true;
			});
		} else {
			_this.loaded = false;
		}
	}
	this.isLoaded = function() {
		return _this.loaded;
	}
	this.hasSubdomain = function() {
		return !_.isEmpty(_this.current);
	}
	this.hasTitle = function() {
		return _this.current.title !== undefined;
	}
	this.hasSubTitle = function() {
		return _this.current.sub_title !== undefined;
	}
	this.hasDescription = function() {
		return _this.current.description !== undefined;
	}
}])
.service('Highlighting', [function(){
	var _this = this;
	this.terms = [];
	this.purge = function() {
		while (_this.terms.length > 0) {
			_this.terms.pop();
		}
	}
	this.set = function(query_array) {
		_this.purge();
		for (var i in query_array) {
			_this.terms.push(query_array[i].text.replace(/['"]/g,""));
		}
	}
}])
.service('ToolListConnection', ['$resource', function($resource){
	return $resource('/api/t/', null, {
		'query': {
			isArray:false,
			method:'GET'
		},
		'update': {
			method:'PUT'
		}
	})
}])
.service('ToolListOverviewConnection', ['$resource', function($resource){
	return $resource('/api/tool-list/', null, {
		'query': {
			isArray:true,
			method:'GET'
		}
	})
}])
.service('ToolList', ['$stateParams', 'ToolListConnection', function($stateParams, ToolListConnection){
	var _this = this;
	this.count = 0;
	this.list = [];
	this.loading = true;

	this.refresh = function() {
		// enable spinner
		this.loading = true;

		// get tools
		var response = ToolListConnection.query($stateParams, function() {
			// disable spinner
			_this.loading = false;
			_this.count = response.count;
			_this.list = response.list;
		});
	}
}])
.factory('ToolTableDataSource', function() {
	var columnDescriptionForKey = function(key, hidden) {
		var widthCharMultiplier = 12;
		var columnDescription = {};
		if (key == 'Name') {
			columnDescription = {field: 'name', displayName: 'Name', cellTemplate: '/partials/grid_cells/nameCell.html', width: '150', resizable: true};
		}
		else if (key == 'Operating System') {
			columnDescription = {field: 'operatingSystem', displayName: 'Operating system', cellTemplate: '/partials/grid_cells/platformCell.html', width: '100', resizable: true};
		}
		else if (key == 'Description') {
			columnDescription = {field: 'description', displayName: 'Description', width: '*', resizable: true, cellTemplate: '/partials/grid_cells/defaultCell.html'};
		}
		else if (key == 'Operation') {
			columnDescription = {field: 'function', displayName: 'Operation', width: '220', resizable: true, cellTemplate: '/partials/grid_cells/functionCell.html'};
		}
		else if (key == 'Input') {
			columnDescription = {field: 'function', displayName: 'Input', width: '240', resizable: true, cellTemplate: '/partials/grid_cells/inputCell.html'};
		}
		else if (key == 'Output') {
			columnDescription = {field: 'function', displayName: 'Output', width: '240', resizable: true, cellTemplate: '/partials/grid_cells/outputCell.html'};
		}
		else if (key == 'Topic') {
			columnDescription = {field: 'topic', displayName: 'Topic', width: '200', resizable: true, cellTemplate: '/partials/grid_cells/topicCell.html'};
		}
		else if (key == 'Homepage') {
			columnDescription = {field: 'homepage', displayName: 'Homepage', resizable: true, width: '100', cellTemplate: '/partials/grid_cells/urlCell.html'};
		}
		else if (key == 'Tool Type') {
			columnDescription = {field: 'toolType', displayName: 'Tool type', width: '150', resizable: true, cellTemplate: '/partials/grid_cells/listCell.html'};
		}
		else if (key == 'Publications') {
			columnDescription = {field: 'publication', displayName: 'Publications', width: '250', resizable: true, cellTemplate: '/partials/grid_cells/publicationsCell.html'};
		}
		else if (key == 'Collection') {
			columnDescription = {field: 'collectionID', displayName: 'Collection', width: '150', resizable: true, cellTemplate: '/partials/grid_cells/listCell.html'};
		}
		else if (key == 'bio.tools ID') {
			columnDescription = {field: 'biotoolsID', displayName: 'bio.tools ID', width: '120', resizable: true, cellTemplate: '/partials/grid_cells/defaultCell.html'};
		}
		else if (key == 'Documentation') {
			columnDescription = {field: 'documentation', displayName: 'Documentation', width: '160', resizable: true, cellTemplate: '/partials/grid_cells/linkListCell.html'};
		}
		else if (key == 'Link') {
			columnDescription = {field: 'link', displayName: 'Links', width: '160', resizable: true, cellTemplate: '/partials/grid_cells/linkListCell.html'};
		}
		else if (key == 'Download') {
			columnDescription = {field: 'download', displayName: 'Downloads', width: '160', resizable: true, cellTemplate: '/partials/grid_cells/linkListCell.html'};
		}
		else if (key == 'Language') {
			columnDescription = {field: 'language', displayName: 'Language', width: '120', resizable: true, cellTemplate: '/partials/grid_cells/listCell.html'};
		}
		else if (key == 'Credits') {
			columnDescription = {field: 'credit', displayName: 'Credits & Support', width: '150', resizable: true, cellTemplate: '/partials/grid_cells/creditsCell.html'};
		}
		else if (key == 'Accessibility') {
			columnDescription = {field: key.toLowerCase(), displayName: key, width: '150', resizable: true, cellTemplate: '/partials/grid_cells/defaultCell.html'};
		}
		else if (key == 'Cost') {
			columnDescription = {field: key.toLowerCase(), displayName: key, width: '90', resizable: true, cellTemplate: '/partials/grid_cells/defaultCell.html'};
		}
		else if (key == 'Version') {
			columnDescription = {field: key.toLowerCase(), displayName: key, width: '90', resizable: true, cellTemplate: '/partials/grid_cells/listCell.html'};
		}
		else {
			columnDescription = {field: key.toLowerCase(), displayName: key, width: key.length * widthCharMultiplier, resizable: true, cellTemplate: '/partials/grid_cells/defaultCell.html'};
		}
		columnDescription.enableHiding = true;
		columnDescription.visible = hidden;
		columnDescription["minWidth"] = 120;
		return columnDescription;
	}

	return {
		columnsDescription : function(visibleColumns) {
			return [
			columnDescriptionForKey('Name', visibleColumns.indexOf('Name') != -1),
			columnDescriptionForKey('Description', visibleColumns.indexOf('Description') != -1),
			columnDescriptionForKey('Homepage', visibleColumns.indexOf('Homepage') != -1),
			columnDescriptionForKey('Version', visibleColumns.indexOf('Homepage') != -1),
			columnDescriptionForKey('bio.tools ID', visibleColumns.indexOf('bio.tools ID') != -1),
			columnDescriptionForKey('Tool Type', visibleColumns.indexOf('Tool Type') != -1),
			columnDescriptionForKey('Topic', visibleColumns.indexOf('Topic') != -1),
			columnDescriptionForKey('Publications', visibleColumns.indexOf('Publications') != -1),
			columnDescriptionForKey('Credits', visibleColumns.indexOf('Credits') != -1),
			columnDescriptionForKey('Operation', visibleColumns.indexOf('Operation') != -1),
			columnDescriptionForKey('Input', visibleColumns.indexOf('Input') != -1),
			columnDescriptionForKey('Output', visibleColumns.indexOf('Output') != -1),
			columnDescriptionForKey('Documentation', visibleColumns.indexOf('Documentation') != -1),
			columnDescriptionForKey('Operating System', visibleColumns.indexOf('Operating System') != -1),
			columnDescriptionForKey('Language', visibleColumns.indexOf('Language') != -1),
			columnDescriptionForKey('License', visibleColumns.indexOf('License') != -1),
			columnDescriptionForKey('Link', visibleColumns.indexOf('Link') != -1),
			columnDescriptionForKey('Accessibility', visibleColumns.indexOf('Accessibility') != -1),
			columnDescriptionForKey('Download', visibleColumns.indexOf('Download') != -1),
			columnDescriptionForKey('Collection', visibleColumns.indexOf('Collection') != -1),
			columnDescriptionForKey('Cost', visibleColumns.indexOf('Cost') != -1),
			columnDescriptionForKey('Maturity', visibleColumns.indexOf('Maturity') != -1)
			];
		}
	}
})
.service('ToolPaginator', function(){
	this.currentPage = 1;
	// pagination settings
	this.maxSize = 5;
	this.pageSize = 10;
})
.service('ToolSorter', function(){
	var _this = this;
	this.order = true;
	this.list = [
	{"attrName": "lastUpdate", "text": "Updated"},
	{"attrName": "additionDate", "text": "Added"},
	{"attrName": "name", "text": "Name"},
	{"attrName": "citationCount", "text": "Citation Count"},
	{"attrName": "citationDate", "text": "Publication Date"}
	];
	this.sortBy = this.list[0];

	var scoreEntry = {"attrName": "score", "text": "Score"};

	this.setSortOption = function(parameter) {
		if (parameter == undefined) {
			this.sortBy = this.list[0];
		}
		else {
			for (var i = 0; i < this.list.length; i++) {
				if (this.list[i]['attrName'] == parameter) {
					this.sortBy = this.list[i];
				}
			}
		}
	} 

	// add 'Score' to the list of sortable attributes
	this.addScore = function () {
		if (!_.isEqual(scoreEntry, _this.list[0])) {
			_this.list.unshift(scoreEntry);
			_this.sortBy = _this.list[0];
		}
	}

	// remove 'Score' from the list of sortable attributes
	this.removeScore = function () {
		if (_.isEqual(scoreEntry, _this.list[0])) {
			_this.list.splice(0,1);
			_this.sortBy = _this.list[0];
		}
	}
})
.service('DisplayModeSelector', function(){
	this.list = [
	{"attrName": "cards", "text": "Compact"},
	{"attrName": "grid", "text": "Detailed"}
	];
	this.mode = this.list[0];
})
.factory('Tool', ['$resource', function($resource){
	return $resource('/api/t/:id', null, {
		'query': {
			isArray:false,
			method:'GET'
		},
		'update': {
			method:'PUT'
		}
	})
}])
.factory('DisownToolService', ['$resource', function($resource){
	return $resource('/api/t/:id/disown', {'id': '@id'}, {
		'disown': {
			method:'POST'
		}
	})
}])
.factory('ToolCreateValidator', ['$resource', function($resource){
	return $resource('/api/t/:id/validate', null, {
		'update': {
			method:'PUT'
		}
	})
}])
.factory('ToolUpdateValidator', ['$resource', function($resource){
	return $resource('/api/t/:id/validate', null, {
		'update': {
			method:'PUT'
		}
	})
}])
.factory('Ontology', ['$resource', function($resource){
	return $resource('/api/o/:name', null, {})
}])
.factory('UsedTerms', ['$resource', function($resource){
	return $resource('/api/used-terms/:usedTermName', null, {
		'query': {
			isArray:true,
			method:'GET'
		},
	})
}])
.service('Attribute', function() {
	this.description = {
		everything: {
			label: "Everything"
		},
		name: {
			description: "Tool name.",
			label: "Name"
		},
		biotoolsID: {
			description: "Unique, persistent bio.tools identifier.",
			label: "biotoolsID"
		},
		toolType: {
			description: "A type of application software: a tool can have more than one type.",
			label: "Tool type"
		},
		version: {
			description: "Tool version information. Use 'Add version' to enter individual version numbers (if practical).",
			label: "Current version"
		},
		description: {
			description: "Tool description, e.g. a few sentences adapted from the tool publication abstract or homepage.",
			label: "Description"
		},
		operation: {
			description: "A basic operation performed by this tool function.",
			label: "Operation"
		},
		functionNote: {
			description: "Concise comment about this function, if not apparent from the description and EDAM annotations.",
			label: "Function description"
		},
		functionName: {
			description: "Name of the function (EDAM term)",
			label: "Function Name"
		},
		input: {
			description: "Details of input data for this function.",
			label: "Input"
		},
		inputDataType: {
			description: "Type of input data.",
			label: "Data type"
		},
		inputDataFormat: {
			description: "Allowed format(s) of the input data.",
			label: "Data format"
		},
		outputDataType: {
			description: "Type of output data.",
			label: "Data type"
		},
		outputDataFormat: {
			description: "Allowed format(s) of the output data.",
			label: "Data format"
		},
		dataDescription: {
			description: "Free text description of the data.",
			label: "Data description"
		},
		output: {
			description: "Details of output data for this function.",
			label: "Output"
		},
		topic: {
			description: "A scientific domain that the tool serves, or another general category.",
			label: "Topic"
		},
		homepage: {
			description: "Homepage of the tool, or some URL that best serves this purpose.",
			label: "Homepage URL"
		},
		contact: {
			description: "Primary points of contact, e.g. helpdesk or an individual",
			label: "Contact"
		},
		contactName: {
			description: "Name of contact",
			label: "Name"
		},
		contactEmail: {
			description: "Email address of contact",
			label: "E-mail"
		},
		resourceType: {
			description: "Basic resource type: Tool, Database etc.",
			label: "Resource type"
		},
		interface: {
			description: "Resource interfaces: Web UI, Command line etc.",
			label: "Interface"
		},
		publications: {
			description: "Publications relevant to the resource (PMCID, PMID or DOI)",
			label: "Publications"
		},
		publicationsPrimaryID: {
			description: "PMCID, PMID or DOI of the publication",
			label: "ID of the primary publication"
		},
		publicationsOtherID: {
			description: "PMCID, PMID or DOI of other relevant publications",
			label: "ID of other publications"
		},
		docs: {
			description: "Links to the documentation",
			label: "Documentation"
		},
		docsHome: {
			description: "Main page of documentation",
			label: "Main page"
		},
		docsTermsOfUse: {
			description: "Link to the Terms Of Use",
			label: "Terms of Use"
		},
		docsDownload: {
			description: "Link to the download instructions",
			label: "Download"
		},
		docsCitationInstructions: {
			description: "Link to the citation instructions",
			label: "Citation instructions"
		},
		docsDownloadSource: {
			description: "Source code downloads page (URL)",
			label: "Download source"
		},
		docsDownloadBinaries: {
			description: "Software binaries downloads page (URL)",
			label: "Download binaries"
		},
		docsGithub: {
			description: "Github page (URL)",
			label: "Github page"
		},
		affiliation: {
			description: "Entry owner",
			label: "Affiliation"
		},
		mirror: {
			description: "Mirror homepage (URL)",
			label: "Mirror"
		},
		collectionID: {
			description: "A tag which assigns the tool to a collection in bio.tools.",
			label: "Collection"
		},
		sourceRegistry: {
			description: "Link to the registry (or other collection) from which the tool was imported (URL)",
			label: "Source registry"
		},
		canonicalID: {
			description: "Canonical Identifier (typically a URI) of the resource, if one is available",
			label: "Canonical ID"
		},
		cost: {
			description: "Monetary cost of acquiring the tool.",
			label: "Cost"
		},
		elixirInfo: {
			description: "Information specific to ELIXIR services",
			label: "ELIXIR info"
		},
		elixirStatus: {
			description: "ELIXIR Core Service",
			label: "ELIXIR status"
		},
		elixirNode: {
			description: "Name of one of countries participating in ELIXIR",
			label: "ELIXIR node"
		},
		maturity: {
			description: "Development stage of the software product.",
			label: "Maturity"
		},
		platform: {
			description: "Platforms supported by a downloadable software package",
			label: "Platform"
		},
		language: {
			description: "Name of a programming language, e.g. used for the tool source code.",
			label: "Language"
		},
		license: {
			description: "Software or data usage license. Use \"Unlicensed\", \"Proprietary\" (for commercial licenses) or \"Other\" in special cases. ",
			label: "License"
		},
		credit: {
			description: "Entities that should be credited",
			label: "Credit"
		},
		creditsDeveloper: {
			description: "Name of person that developed the resource",
			label: "Developer"
		},
		creditsContributor: {
			description: "Name of person contributing to the resource",
			label: "Contributor"
		},
		creditsInstitution: {
			description: "Name of the institution that developed or provide the resource",
			label: "Institution"
		},
		creditsInfrastructure: {
			description: "Research infrastructure in which the resource was developed or provided",
			label: "Infrastructure"
		},
		creditsFunding: {
			description: "Details of grant funding supporting the resource",
			label: "Funding"
		},
		uses: {
			description: "Other resources this resource uses, e.g. as a data source, or auxillary program",
			label: "Uses"
		},
		usesName: {
			description: "Name of a resource that this resource uses",
			label: "Name"
		},
		usesHomepage: {
			description: "Homepage of a resource that this resource uses",
			label: "Homepage"
		},
		usesVersion: {
			description: "Version number of a resource that this resources uses",
			label: "Version"
		},
		operatingSystem: {
			description: "The operating system supported by a downloadable software.",
			label: "Operating system"
		},
		accessibility: {
			description: "How freely available the software is for use.",
			label: "Accessibility"
		},
		cmd: {
			description: "Relevant command, command-line fragment or option for executing this function or running the tool in this mode.",
			label: "Command"
		},
		linkURL: {
			description: "A link of some relevance to the tool (URL).",
			label: "linkURL"
		},
		linkType: {
			description: "The type of data, information or system that is obtained when the link is resolved.",
			label: "linkType"
		},
		linkNote: {
			description: "Comment about the link.",
			label: "linkNote"
		},
		downloadURL: {
			description: "Link to download (or repository providing a download) for the tool.",
			label: "downloadURL"
		},
		downloadType: {
			description: "Type of downloadable resource.",
			label: "downloadType"
		},
		downloadNote: {
			description: "Comment about the download.",
			label: "downloadNote"
		},
		downloadVersion: {
			description: "Version information (typically a version number) of the software applicable to this download.",
			label: "linkNote"
		},
		documentationURL: {
			description: "Link to documentation for the tool (URL).",
			label: "documentationURL"
		},
		documentationType: {
			description: "Type of documentation that is linked to.",
			label: "documentationType"
		},
		documentationNote: {
			description: "Comment about the documentation.",
			label: "documentationNote"
		},
		publicationPMCID: {
			description: "PubMed Central Identifier (PMCID) of a publication about the tool.",
			label: "publicationPMCID"
		},
		publicationPMID: {
			description: "PubMed Identifier (PMID) of a publication about the tool.",
			label: "publicationPMID"
		},
		publicationDOI: {
			description: "Digital Object Identifier (DOI) of a publication about the tool.",
			label: "publicationDOI"
		},
		publicationType: {
			description: "Type of publication.",
			label: "publicationType"
		},
		publicationVersion: {
			description: "Version information (typically a version number) of the software applicable to this publication.",
			label: "publicationVersion"
		},
		publicationNote: {
			description: "Comment about the publication.",
			label: "publicationNote"
		},
		creditName: {
			description: "Name of the entity that is credited.",
			label: "creditName"
		},
		creditEmail: {
			description: "Email address of the entity that is credited.",
			label: "creditEmail"
		},
		creditURL: {
			description: "URL for the entity that is credited, e.g. homepage of an institute.",
			label: "creditURL"
		},
		creditOrcidID: {
			description: "Unique identifier (ORCID iD) of a person that is credited.",
			label: "creditOrcidID"
		},
		creditGridID: {
			description: "Unique identifier (GRID ID) of an organisation that is credited.",
			label: "creditGridID"
		},
		creditRORID: {
			description: "Unique identifier (ROR ID) of an organisation that is credited.",
			label: "creditRORID"
		},
		creditFundRefID: {
			description: "Unique identifier (FundRef ID) of an organisation that is credited.",
			label: "creditFundRefID"
		},
		creditEntityType: {
			description: "Type of entity that is credited.",
			label: "creditEntityType"
		},
		creditEntityRole: {
			description: "Role performed by entity that is credited.",
			label: "creditEntityRole"
		},
		creditNote: {
			description: "A comment about the credit.",
			label: "creditNote"
		},
		elixirPlatform: {
			description: "Name of one of countries participating in ELIXIR",
			label: "elixirPlatform"
		},
		elixirCommunity: {
			description: "Name of the community participating in ELIXIR",
			label: "elixirCommunity"
		},
		otherID: {
			description: "A unique identifier of the tool, typically assigned by an ID-assignment authority other than bio.tools, e.g. “RRID:SCR_015644”",
			label: "otherID"
		},
		otherIDValue: {
			description: "Value of tool identifier, e.g. “RRID:SCR_001156”",
			label: "otherIDValue"
		},
		otherIDType: {
			description: "Type of tool identifier, e.g. “rrid”",
			label: "otherIDType"
		},
		otherIDVersion: {
			description: "Version information (typically a version number) of the software applicable to this identifier, e.g. “1.4”",
			label: "otherIDVersion"
		},
		relationBiotoolsID: {
			description: 'bio.tools ID of an existing bio.tools entry to which this tool is related, e.g. "needle"',
			label: "relationBiotoolsID"
		},
		relationType: {
			description: 'Type of relation between this and another registered tool, e.g. "isNewVersionOf"',
			label: "relationType"
		},
		confidence: {
			description: 'Related to automatically generated entries from publications: describes the confidence score of an entry being a valid bio.tools entry.',
			label: "Tool confidence"
		},
		bioLibAppName: {
			description: 'Application Name of an existing BioLib app',
			label: "App name"
		},
		bioLibAuthorUsername: {
			description: 'Username of the user that created the BioLib app',
			label: "Author username"
		},
		bioLibAuthorName: {
			description: 'The display name of the author that created the BioLib app',
			label: "Author name"
		}
	};
})
.factory('CheckUserEditingRights', ['User', function(User) {
	return {
		canEdit: function(resource) {

			if (User.isSuperuser()) return true;

			if (User.getUsername() == resource.owner) {
				return true;
			}
			else if (resource.editPermission != undefined) {
				if (resource.editPermission.type == "public") {
					return true;
				}
				else if (resource.editPermission.type == "group") {
					for (var index in resource.editPermission.authors) {
						if (User.getUsername() == resource.editPermission.authors[index]) {
							return true;
						}
					}
				}
			}
			return false;
		},
		isOwner: function(resource) {
			if (User.getUsername() == resource.owner) {
				return true;
			}
			return false;
		}
	};
}])
.factory('ToolVersionProvider', ['$http', function ($http) {
	return {
		getVersions: function(toolId) {
			return $http({
				method: 'GET',
				url: '/api/tool/' + toolId + '/version'
			}).then(function successCallback(response) {
				return response.data;
			}, function errorCallback(response) {
				return [];
			})
		}
	};
}])
.factory('EnvironmentChecker', ['$http', function ($http) {
	return {
		getEnvironment: function() {
			return $http({
				method: 'GET',
				url: '/api/env/'
			}).then(function successCallback(response) {
				return response.data;
			}, function errorCallback(response) {
				return [];
			})
		}
	};
}])
.service('Covid', function(){
	self.tag = 'COVID-19';
	this.hasCovid = function(collection){
		if (collection && Array.isArray(collection) && collection.length > 0){
			return collection.includes(self.tag);
		}
		return false;
	}

	this.addCovid = function(collection){
		if (!this.hasCovid(collection)){
			
			// if the collection property is not set or is set but is not an array
			if (!collection || (collection && !Array.isArray(collection))){
				return [self.tag];
			}
			if (Array.isArray(collection)){
				collection.push(self.tag);
				return collection;
			}
		}
	}
	this.removeCovid = function(collection){
		var result = [];
		if (this.hasCovid(collection)){
			result = collection.filter(function(c){
				return c != self.tag;
			});
		}
		if (result.length == 0){
			return undefined
		}
		return result;
	}
})
.service('CommunityCollection', function(){
	this.hasCommunityCollection = function(collectionList, communityCollection){
		if (collectionList && Array.isArray(collectionList) && collectionList.length > 0){
			return collectionList.includes(communityCollection);
		}
		return false;
	}

	this.addCommunityCollection = function(collectionList, communityCollection){
		if (!this.hasCommunityCollection(collectionList, communityCollection)){
			
			// if the collection property is not set or is set but is not an array
			if (!collectionList || (collectionList && !Array.isArray(collectionList))){
				return [communityCollection];
			}
			if (Array.isArray(collectionList)){
				collectionList.push(communityCollection);
				return collectionList;
			}
		}
	}

	this.removeCommunityCollection = function(collectionList, communityCollection){
		var result = [];
		if (this.hasCommunityCollection(collectionList, communityCollection)){
			result = collectionList.filter(function(c){
				return c != communityCollection;
			});
		}
		if (result.length == 0){
			return undefined
		}
		return result;
	}
});

// Controllers
angular.module('elixir_front.controllers')
.controller('SubdomainAdminController', ['$scope',  '$stateParams', 'DomainConnection', 'DomainDetailConnection', function($scope, $stateParams, DomainConnection, DomainDetailConnection) {
	var vm = this;
	$scope.isLoadingSubdomains = true;
	$scope.subdomains = [];

	$scope.deleteSubdomainAtIndex = function(index){
		if (confirm("Are you sure you want to remove this subdomain?")){
			// COVID-19 subdomain hack
			if ($scope.subdomains[index].name.toLowerCase() == 'covid-19'){
				alert('Cannot delete the covid-19 subdomain');
				return;
			}
			var deleteSubdomain = $scope.subdomains[index];
			$scope.subdomains.splice(index, 1);
			var deleteResponse = DomainDetailConnection.delete({'domain': deleteSubdomain.name}, function(data) {
				// TODO: Handle repsonses
			}, function(error) {
				// TODO: Handle errors
			});
		}
	}

	vm.loadSubdomains = function() {
		$scope.isLoadingSubdomains = true;
		$scope.subdomains = [];
		var domainResponse = DomainConnection.query({}, function(data) {
			$scope.subdomains = data;
			$scope.isLoadingSubdomains = false;
		}, function(errorData) {
			// TODO: Handle errors
		});
	};

	// Initialization
	vm.loadSubdomains()
}])
.controller('DomainListController', ['$scope', 'DomainDetailConnection', '$state', function($scope, DomainDetailConnection, $state){
	var vm = this;
	$scope.domains = [];
	$scope.domainSearchText = "";
	
	$scope.search_title = true;
	$scope.search_subtitle = true;
	$scope.search_collection = true;
	$scope.search_tags = true;
	$scope.search_description = false;
	$scope.search_tools = false;

	$scope.updateKeys = function(){
		$scope.initialKeys = [
			{
				"name":"domain",
				"weight": 1
			},
			{
				"name":"title",
				"weight": $scope.search_title ? 0.9 : 0
			},
			{
				"name":"sub_title",
				"weight": $scope.search_subtitle ? 0.7 : 0
			},
			{
				"name":"tag",
				"weight": $scope.search_tags ? 0.9 : 0
			},
			{
				"name":"collection",
				"weight": $scope.search_collection ? 0.9 : 0
			}, 
			{
				"name":"description",
				"weight": $scope.search_description ? 0.3 : 0
			},
			{
				"name":"resources.name",
				"weight": $scope.search_tools ? 0.2 : 0
			},
			{
				"name":"resources.biotoolsID",
				"weight": $scope.search_tools ? 0.2 : 0
			}
		];
		
		$scope.fuseSearchKeys = $scope.initialKeys.filter(function(x){
			return x.weight > 0;
		});

		$scope.fuseOptions = {
			threshold: 0.2,
			shouldSort: true,
			minMatchCharLength: 2,
			// location: 0, default 0
			tokenize: true,
			// matchAllTokens: true,
			keys: $scope.fuseSearchKeys 
	
		};
	}

	$scope.updateKeys();

	DomainDetailConnection.query({'domain':'all'}, function(response) {
		$scope.domains = response.data;
		$scope.domains.sort(function(a,b){
			var d_a = a.domain.toLowerCase();
			var d_b = b.domain.toLowerCase();

			if (d_a < d_b) {
				return -1;
			  }
			  if (d_a > d_b) {
				return 1;
			  }
			  return 0; 
		})
		$scope.filteredDomains = $scope.domains;
		$scope.fuse = new Fuse($scope.domains, $scope.fuseOptions);
	});

	$scope.collectionNameClicked = function(collectionName) {
		$state.go('search', {'collectionID': '"'+ collectionName + '"'});
	}

	$scope.domainSearch = function(){
		if ($scope.domainSearchText.length == 0){
			$scope.filteredDomains = $scope.domains;
		}
		else {
			$scope.updateKeys();
			$scope.fuse = new Fuse($scope.domains, $scope.fuseOptions);
			console.log($scope.fuseOptions);
			$scope.filteredDomains = $scope.fuse.search($scope.domainSearchText);
		}
	}


}])
.controller('SubdomainController', ['$scope', '$state',  '$stateParams', 'ToolListOverviewConnection', 'DomainDetailConnection', 'DomainConnection', '$q', 'UsedTerms', function($scope, $state, $stateParams, ToolListOverviewConnection, DomainDetailConnection, DomainConnection, $q, UsedTerms) {
	var vm = this;
	$scope.ToolListOverviewConnection = ToolListOverviewConnection;
	$scope.updating = false;
	$scope.loading = ($stateParams.id != "");
	$scope.toolsPerPageCount = 10; 

	$scope.search = {};
	$scope.search.searchOption = 'name';
	$scope.search.loadingSearchResults = false;
	$scope.search.searchResults = [];
	$scope.search.searchString = '';
	$scope.search.noResults = false;
	$scope.search.currentPage = 1;
	$scope.search.totalPages = 1;

	$scope.subdomain = {};	
	$scope.subdomain.exists = ($stateParams.id != "");
	$scope.subdomain.domain = $stateParams.id;
	$scope.subdomain.title = '';
	$scope.subdomain.subtitle = '';
	$scope.subdomain.description = '';
	$scope.subdomain.toolList = [];
	$scope.subdomain.resources = [];
	$scope.subdomain.tag = [];
	$scope.subdomain.collection = [];
	$scope.subdomain.is_private = true;
	$scope.subdomain.currentPage = 1;
	$scope.subdomain.totalPages = 1;

	$scope.errors = {};
	$scope.errors.general = '';
	$scope.errors.domain = '';
	$scope.errors.loading = '';
	$scope.errors.data = {}


	$scope.response = {};
	$scope.response.general = '';


	$scope.gotoDomain = function(d){
		if (confirm('Make sure to save before leaving the page. Leave?')){
			$state.go('subdomain', {domain: d});
		}
		
	}

	// Handle tool search
	$scope.clearButtonPressed = function() {
		$scope.search.currentPage = 1;
		var searchQuery = {}
		searchQuery[$scope.search.searchOption] = $scope.search.searchString;
		$scope.search.searchResults = [];
	};

	$scope.searchButtonPressed = function() {
		$scope.search.currentPage = 1;
		var searchQuery = {}
		searchQuery[$scope.search.searchOption] = $scope.search.searchString;
		vm.performSearch(searchQuery);
	};

	$scope.toolInSubdomain = function(toolID, versionID) {
		for (var index in $scope.subdomain.resources) {
			var currentTool = $scope.subdomain.resources[index];
			
			if (currentTool['biotoolsID'] == toolID){// && currentTool['versionId'] == versionID) {
				return true;
			}
		}
		return false;
	}

	$scope.addToSubdomain = function(index) {
		var selectedTool = $scope.search.searchResults[index];
		
		var selectedDict = { "biotoolsID": selectedTool.biotoolsID, "versionId": selectedTool.versionId };
		$scope.subdomain.toolList.push(selectedTool);
		$scope.subdomain.resources.push(selectedDict);
		$scope.subdomain.totalPages = ($scope.subdomain.toolList.length / $scope.toolsPerPageCount) * 10;
	}

	$scope.domainAddButtonClick = function (_what, _where, _isList, _isObject) {
		if (_isList) {
			// if array does not exist create it
			if (typeof _where[_what] == 'undefined') {
				_where[_what] = [];
			}
			// add either an object or string to array
			_where[_what].push(_isObject ? {} : '');
		} else {
			// if object does not exist create it
			if (typeof _where[_what] == 'undefined') {
				_where[_what] = _isObject ? {} : '';
			}
		}
	}

	$scope.removeButtonClick = function (_what, _parent, _index, _event){
		$scope.removeButtonClickAux(_what, _parent, _index, _event);

		if ($scope.errors.data[_what] && $scope.errors.data[_what][_index]){
			$scope.removeButtonClickAux(_what, $scope.errors.data, _index, _event);
		}
		
	}

	// remove attribute or list entry
	$scope.removeButtonClickAux = function (_what, _parent, _index, _event) {
		if (_parent[_what][_index] ? confirm("Are you sure you want to remove this element?") : 1) {
			// remove jstree if exists
			if (_event) {
				$(_event.target).closest('div').find('.jstree').jstree("destroy").remove();
			}
			_parent[_what].splice(_index, 1);
			// if last instance in array delete entire attribute from the software object
			if (_parent[_what].length == 0) {
				delete _parent[_what];
			}
		}
	}

	// used terms (collectionID) for searching in collections
	function getCollectionIDs(){
		var d = $q.defer();
		var params = {
			"usedTermName": "collectionID"
		};
		UsedTerms.get(params, function(response) {
			d.resolve(response.data);
		});
		return d.promise;
	}
	
	$scope.loadCollectionIDs = function(query) {
		return getCollectionIDs().then(function(list) {
			return list.filter(function (str) { return str.toLowerCase().includes(query.toLowerCase()); }).slice(0,10).sort();
		});
	}

	$scope.addAllToSubdomain = function() {
		for (var tool in $scope.search.searchResults) {
			var selectedTool = $scope.search.searchResults[tool];
			if (selectedTool.biotoolsID && $scope.toolInSubdomain(selectedTool.biotoolsID, selectedTool.versionId) == false) {	
				$scope.subdomain.toolList.push(selectedTool);
				$scope.subdomain.resources.push({ "biotoolsID": selectedTool.biotoolsID, "versionId": selectedTool.versionId });
			}
		}
		$scope.subdomain.totalPages = ($scope.subdomain.toolList.length / $scope.toolsPerPageCount) * 10;
	}

	$scope.removeFromSubdomain = function(index) {
		$scope.subdomain.toolList.splice(index, 1); 
		$scope.subdomain.resources.splice(index, 1);
		$scope.subdomain.totalPages = ($scope.subdomain.toolList.length / $scope.toolsPerPageCount) * 10;
	}

	$scope.saveSubdomain = function() {
		$scope.updating = true;
		$scope.errors.general = '';
		$scope.response.general = '';
		var createResponse = DomainConnection.create(vm.subdomainQuery(), function(data) {
			$scope.subdomain.exists = true;
			$scope.response.general = "Domain '" + $scope.subdomain.domain + "' was created.";
			$scope.updating = false;
		}, function(error) {
			$scope.errors.general = error.data.detail;
			console.log(error);
			$scope.updating = false;
			$scope.errors.data = error.data;
		});
	}

	vm.fetchSubdomain = function() {
		$scope.errors.general = '';
		$scope.response.general = '';
		var updateResponse = DomainDetailConnection.query({'domain': $scope.subdomain.domain}, function(data) {
			$scope.subdomain.title = data.data['title'];
			$scope.subdomain.subtitle = data.data['sub_title'];
			$scope.subdomain.description = data.data['description'];
			for (var index in data.data.resources) {
				var tool = data.data.resources[index];
				tool['biotoolsID'] = tool['biotoolsID'];
				$scope.subdomain.toolList.push(tool);
				$scope.subdomain.resources.push(tool);
			}

			for (var i in data.data.tag){
				$scope.subdomain.tag.push(data.data.tag[i]);
			}
		
			for (var i in data.data.collection){
				$scope.subdomain.collection.push(data.data.collection[i]);
			}

			$scope.subdomain.is_private = data.data.is_private;

			$scope.loading = false;
			$scope.updating = false;
			$scope.subdomain.totalPages = ($scope.subdomain.toolList.length / $scope.toolsPerPageCount) * 10;
		}, function(error) {
			// Handle error
			$scope.errors.loading = 'Data failed to load. Please try to refresh this website. ' + error.data.details;
		});
	}

	$scope.updateSubdomain = function() {
		$scope.updating = true;
		$scope.errors.general = '';
		$scope.response.general = '';
		var updateResponse = DomainDetailConnection.update(vm.subdomainQuery(), function(data) {
			$scope.response.general = "Domain '" + $scope.subdomain.domain + "' was updated with " + $scope.subdomain.resources.length + " entries." ;
			$scope.updating = false;
		}, function(error) {
			$scope.errors.general = error.data.detail;
			$scope.updating = false;
			$scope.errors.data = error.data;
		});
	}

	// remove or replace characters not allowed for subdomains
	// See https://tools.ietf.org/html/rfc952 for guidelines
	$scope.makeSubdomainURLSafe = function(value) {
		$scope.errors.domain = "";
		if (typeof value != 'undefined') {
			var id = value.replace(/[^a-zA-Z0-9_-]*/g,'').replace(/[ ]+/g, '-').replace(/[_]+/g, '-').toLowerCase();
		}
		if (value != id) {
			$scope.errors.domain = "Entered value '" + value + "' has been modified. Only alphanumeric characters and dashes can be used for the subdomain name.";
		}
		$scope.subdomain.domain = id;
	}


	vm.performSearch = function(query) {
		$scope.search.loadingSearchResults = true;
		$scope.search.noResults = false;
		var response = ToolListOverviewConnection.query(query, function() {
			$scope.search.currentPage = 1;
			$scope.search.searchResults = response;
			$scope.search.loadingSearchResults = false;
			$scope.search.totalPages = ($scope.search.searchResults.length / $scope.toolsPerPageCount) * 10;
			if (response.length == 0) {
				$scope.search.noResults = true;
			}
		});
	};

	vm.subdomainQuery = function() {
		return {'domain': $scope.subdomain.domain,
		'title': $scope.subdomain.title,
		'sub_title': $scope.subdomain.subtitle,
		'description': $scope.subdomain.description,
		'resources': $scope.subdomain.resources,
		'tag': $scope.subdomain.tag,
		'collection': $scope.subdomain.collection,
		'is_private': $scope.subdomain.is_private
	};
}

	// Initialization
	if ($scope.loading) {
		vm.fetchSubdomain()
	}
}]);


// Controllers
angular.module('elixir_front.controllers')
.controller('WorkflowController', ['$scope',  '$stateParams', '$modal', 'WorkflowProvider', function($scope, $stateParams, $modal, WorkflowProvider) {
	var vm = this;
	$scope.loading = true
	$scope.filteredWorkflows = []
	$scope.workflows = []

	// Data feteching
	vm.loadRequests = function($item, $model, $label) {
		$scope.loading = true;
		WorkflowProvider.getWorkflows().then(function successCallback(response) {
			$scope.workflows = response.data;
			$scope.filterWorkflows();
			$scope.loading = false;
		}, function errorCallback(response) {
			//TODO: Handle error
		});
	};	

	$scope.filterWorkflows = function() {
		var searchString = $scope.search.searchString;
		if (searchString == undefined || searchString == '') {
			$scope.filteredWorkflows = $scope.workflows;
		}
		else {
			$scope.filteredWorkflows = $scope.workflows.filter(function(x) {
				var foundAnnotations = x.annotations.filter(function(annotation) {
					var regularExpression = new RegExp(searchString,"i");
					if (annotation.title.match(regularExpression) || annotation.title.match(regularExpression) || annotation.edam_term.match(regularExpression)) {
						return true;
					}
					return false;
				});
				return foundAnnotations.length > 0;
			});
		}
	}

	$scope.openModal = function(workflow) {
		$modal.open({
			templateUrl: 'partials/workflows/modal.html',
			controller: ['$modalInstance', 'workflow', WorkflowModalCtrl],
			controllerAs: 'vm',
			windowClass: 'workflow-modal-window',
			resolve: {
				workflow: function () { return workflow },
			}
		});
	};

	$scope.handleAnnotationClick = function(annotation) {
		console.log(annotation);
	}

	$scope.search = function() {
		console.log(string);
	};

	// Initialization
	vm.loadRequests();
}]);

function WorkflowModalCtrl($modalInstance, workflow) {
	var vm = this;
	vm.workflow = workflow;
	vm.currentTitle = "";
	vm.currentDescription = "";
	vm.currentEdam = "";

	vm.mapDimensions = function(annotation) {
		return vm.mapXDimension(annotation.startX) + "," + vm.mapYDimension(annotation.startY) + "," + vm.mapXDimension(annotation.endX) + "," + vm.mapYDimension(annotation.endY);
	}

	vm.imageHeight = function() {
		var img = document.getElementById('image'); 
		return img.clientHeight;
	}

	vm.imageWidth = function() {
		var img = document.getElementById('image'); 
		return img.clientWidth;
	}

	vm.mapXDimension = function(dim_x) {
		var multiplier_x = vm.imageWidth() / vm.workflow.width
		return dim_x * multiplier_x
	}

	vm.mapYDimension = function(dim_y) {
		var multiplier_y = vm.imageHeight() / vm.workflow.height
		return dim_y * multiplier_y
	}

	vm.hover = function(annotation) {
		vm.currentTitle = annotation.title;
		vm.currentDescription = annotation.description;
		vm.currentEdam = annotation.edam_term;
	}

	vm.endHover = function(annotation) {
		vm.currentTitle = "";
		vm.currentDescription = "";
		vm.currentEdam = "";
	}
}

// Services and Factories
var elixir_front = angular.module('elixir_front');
elixir_front.factory('WorkflowProvider', ['$http', function ($http) {
	return {
		getWorkflows: function() {
			return $http({
				method: 'GET',
				url: '/api/w',
				params: {}
			})
		}
	};
}]);
(function() {
  var module,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module = angular.module('angularBootstrapNavTree', []);

  module.directive('abnTree', [
    '$timeout', function($timeout) {
      return {
        restrict: 'E',
        template: "<ul class=\"nav nav-list nav-pills nav-stacked abn-tree\">\n  <li tooltips tooltip-side=\"right\" tooltip-content=\"{{ resourceModel[row.branch.name].description }}\" ng-repeat=\"row in tree_rows | filter:{visible:true} track by row.branch.uid\" ng-animate=\"'abn-tree-animate'\" ng-class=\"'level-' + {{ row.level }} + (row.branch.selected ? ' active':'') + ' ' +row.classes.join(' ')\" class=\"abn-tree-row\"><a ng-click=\"user_clicks_branch(row.branch)\"><i ng-class=\"row.tree_icon\" ng-click=\"row.branch.expanded = !row.branch.expanded\" class=\"indented tree-icon\"> </i><span class=\"indented tree-label\"> {{ resourceModel[row.branch.name].label }} </span></a></li>\n</ul>",
        replace: true,
        scope: {
          treeData: '=',
          onSelect: '&',
          initialSelection: '@',
          treeControl: '=',
          resourceModel: '='
        },
        link: function(scope, element, attrs) {
          var error, expand_all_parents, expand_level, for_all_ancestors, for_each_branch, get_parent, n, on_treeData_change, select_branch, selected_branch, tree;
          error = function(s) {
            
            debugger;
            return void 0;
          };
          if (attrs.iconExpand == null) {
            attrs.iconExpand = 'icon-plus  glyphicon glyphicon-plus  fa fa-plus';
          }
          if (attrs.iconCollapse == null) {
            attrs.iconCollapse = 'icon-minus glyphicon glyphicon-minus fa fa-minus';
          }
          if (attrs.iconLeaf == null) {
            attrs.iconLeaf = 'icon-file  glyphicon glyphicon-file  fa fa-file';
          }
          if (attrs.expandLevel == null) {
            attrs.expandLevel = '3';
          }
          expand_level = parseInt(attrs.expandLevel, 10);
          if (!scope.treeData) {
            alert('no treeData defined for the tree!');
            return;
          }
          if (scope.treeData.length == null) {
            if (treeData.label != null) {
              scope.treeData = [treeData];
            } else {
              alert('treeData should be an array of root branches');
              return;
            }
          }
          for_each_branch = function(f) {
            var do_f, root_branch, _i, _len, _ref, _results;
            do_f = function(branch, level) {
              var child, _i, _len, _ref, _results;
              f(branch, level);
              if (branch.children != null) {
                _ref = branch.children;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  child = _ref[_i];
                  _results.push(do_f(child, level + 1));
                }
                return _results;
              }
            };
            _ref = scope.treeData;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              root_branch = _ref[_i];
              _results.push(do_f(root_branch, 1));
            }
            return _results;
          };
          selected_branch = null;
          select_branch = function(branch) {
            if (!branch) {
              if (selected_branch != null) {
                selected_branch.selected = false;
              }
              selected_branch = null;
              return;
            }
            if (branch !== selected_branch) {
              if (selected_branch != null) {
                selected_branch.selected = false;
              }
              branch.selected = true;
              selected_branch = branch;
              expand_all_parents(branch);
              if (branch.onSelect != null) {
                return $timeout(function() {
                  return branch.onSelect(branch);
                });
              } else {
                if (scope.onSelect != null) {
                  return $timeout(function() {
                    return scope.onSelect({
                      branch: branch
                    });
                  });
                }
              }
            }
          };
          scope.user_clicks_branch = function(branch) {
            if (branch !== selected_branch) {
              return select_branch(branch);
            }
          };
          get_parent = function(child) {
            var parent;
            parent = void 0;
            if (child.parent_uid) {
              for_each_branch(function(b) {
                if (b.uid === child.parent_uid) {
                  return parent = b;
                }
              });
            }
            return parent;
          };
          for_all_ancestors = function(child, fn) {
            var parent;
            parent = get_parent(child);
            if (parent != null) {
              fn(parent);
              return for_all_ancestors(parent, fn);
            }
          };
          expand_all_parents = function(child) {
            return for_all_ancestors(child, function(b) {
              return b.expanded = true;
            });
          };
          scope.tree_rows = [];
          on_treeData_change = function() {
            var add_branch_to_list, root_branch, _i, _len, _ref, _results;
            for_each_branch(function(b, level) {
              if (!b.uid) {
                return b.uid = "" + Math.random();
              }
            });
            
            for_each_branch(function(b) {
              var child, _i, _len, _ref, _results;
              if (angular.isArray(b.children)) {
                _ref = b.children;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  child = _ref[_i];
                  _results.push(child.parent_uid = b.uid);
                }
                return _results;
              }
            });
            scope.tree_rows = [];
            for_each_branch(function(branch) {
              var child, f;
              if (branch.children) {
                if (branch.children.length > 0) {
                  f = function(e) {
                    if (typeof e === 'string') {
                      return {
                        label: e,
                        children: []
                      };
                    } else {
                      return e;
                    }
                  };
                  return branch.children = (function() {
                    var _i, _len, _ref, _results;
                    _ref = branch.children;
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                      child = _ref[_i];
                      _results.push(f(child));
                    }
                    return _results;
                  })();
                }
              } else {
                return branch.children = [];
              }
            });
            add_branch_to_list = function(level, branch, visible) {
              var child, child_visible, tree_icon, _i, _len, _ref, _results;
              if (branch.expanded == null) {
                branch.expanded = false;
              }
              if (branch.classes == null) {
                branch.classes = [];
              }
              if (!branch.noLeaf && (!branch.children || branch.children.length === 0)) {
                tree_icon = attrs.iconLeaf;
                if (__indexOf.call(branch.classes, "leaf") < 0) {
                  branch.classes.push("leaf");
                }
              } else {
                if (branch.expanded) {
                  tree_icon = attrs.iconCollapse;
                } else {
                  tree_icon = attrs.iconExpand;
                }
              }
              scope.tree_rows.push({
                level: level,
                branch: branch,
                label: branch.label,
                classes: branch.classes,
                tree_icon: tree_icon,
                visible: visible
              });
              if (branch.children != null) {
                _ref = branch.children;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  child = _ref[_i];
                  child_visible = visible && branch.expanded;
                  _results.push(add_branch_to_list(level + 1, child, child_visible));
                }
                return _results;
              }
            };
            _ref = scope.treeData;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              root_branch = _ref[_i];
              _results.push(add_branch_to_list(1, root_branch, true));
            }
            return _results;
          };
          scope.$watch('treeData', on_treeData_change, true);
          if (attrs.initialSelection != null) {
            for_each_branch(function(b) {
              if (b.label === attrs.initialSelection) {
                return $timeout(function() {
                  return select_branch(b);
                });
              }
            });
          }
          n = scope.treeData.length;
          
          for_each_branch(function(b, level) {
            b.level = level;
            return b.expanded = b.level < expand_level;
          });
          if (scope.treeControl != null) {
            if (angular.isObject(scope.treeControl)) {
              tree = scope.treeControl;
              tree.expand_all = function() {
                return for_each_branch(function(b, level) {
                  return b.expanded = true;
                });
              };
              tree.collapse_all = function() {
                return for_each_branch(function(b, level) {
                  return b.expanded = false;
                });
              };
              tree.get_first_branch = function() {
                n = scope.treeData.length;
                if (n > 0) {
                  return scope.treeData[0];
                }
              };
              tree.select_first_branch = function() {
                var b;
                b = tree.get_first_branch();
                return tree.select_branch(b);
              };
              tree.get_selected_branch = function() {
                return selected_branch;
              };
              tree.get_parent_branch = function(b) {
                return get_parent(b);
              };
              tree.select_branch = function(b) {
                select_branch(b);
                return b;
              };
              tree.get_children = function(b) {
                return b.children;
              };
              tree.select_parent_branch = function(b) {
                var p;
                if (b == null) {
                  b = tree.get_selected_branch();
                }
                if (b != null) {
                  p = tree.get_parent_branch(b);
                  if (p != null) {
                    tree.select_branch(p);
                    return p;
                  }
                }
              };
              tree.add_branch = function(parent, new_branch) {
                if (parent != null) {
                  parent.children.push(new_branch);
                  parent.expanded = true;
                } else {
                  scope.treeData.push(new_branch);
                }
                return new_branch;
              };
              tree.add_root_branch = function(new_branch) {
                tree.add_branch(null, new_branch);
                return new_branch;
              };
              tree.expand_branch = function(b) {
                if (b == null) {
                  b = tree.get_selected_branch();
                }
                if (b != null) {
                  b.expanded = true;
                  return b;
                }
              };
              tree.collapse_branch = function(b) {
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  b.expanded = false;
                  return b;
                }
              };
              tree.get_siblings = function(b) {
                var p, siblings;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  p = tree.get_parent_branch(b);
                  if (p) {
                    siblings = p.children;
                  } else {
                    siblings = scope.treeData;
                  }
                  return siblings;
                }
              };
              tree.get_next_sibling = function(b) {
                var i, siblings;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  siblings = tree.get_siblings(b);
                  n = siblings.length;
                  i = siblings.indexOf(b);
                  if (i < n) {
                    return siblings[i + 1];
                  }
                }
              };
              tree.get_prev_sibling = function(b) {
                var i, siblings;
                if (b == null) {
                  b = selected_branch;
                }
                siblings = tree.get_siblings(b);
                n = siblings.length;
                i = siblings.indexOf(b);
                if (i > 0) {
                  return siblings[i - 1];
                }
              };
              tree.select_next_sibling = function(b) {
                var next;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  next = tree.get_next_sibling(b);
                  if (next != null) {
                    return tree.select_branch(next);
                  }
                }
              };
              tree.select_prev_sibling = function(b) {
                var prev;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  prev = tree.get_prev_sibling(b);
                  if (prev != null) {
                    return tree.select_branch(prev);
                  }
                }
              };
              tree.get_first_child = function(b) {
                var _ref;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  if (((_ref = b.children) != null ? _ref.length : void 0) > 0) {
                    return b.children[0];
                  }
                }
              };
              tree.get_closest_ancestor_next_sibling = function(b) {
                var next, parent;
                next = tree.get_next_sibling(b);
                if (next != null) {
                  return next;
                } else {
                  parent = tree.get_parent_branch(b);
                  return tree.get_closest_ancestor_next_sibling(parent);
                }
              };
              tree.get_next_branch = function(b) {
                var next;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  next = tree.get_first_child(b);
                  if (next != null) {
                    return next;
                  } else {
                    next = tree.get_closest_ancestor_next_sibling(b);
                    return next;
                  }
                }
              };
              tree.select_next_branch = function(b) {
                var next;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  next = tree.get_next_branch(b);
                  if (next != null) {
                    tree.select_branch(next);
                    return next;
                  }
                }
              };
              tree.last_descendant = function(b) {
                var last_child;
                if (b == null) {
                  debugger;
                }
                n = b.children.length;
                if (n === 0) {
                  return b;
                } else {
                  last_child = b.children[n - 1];
                  return tree.last_descendant(last_child);
                }
              };
              tree.get_prev_branch = function(b) {
                var parent, prev_sibling;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  prev_sibling = tree.get_prev_sibling(b);
                  if (prev_sibling != null) {
                    return tree.last_descendant(prev_sibling);
                  } else {
                    parent = tree.get_parent_branch(b);
                    return parent;
                  }
                }
              };
              return tree.select_prev_branch = function(b) {
                var prev;
                if (b == null) {
                  b = selected_branch;
                }
                if (b != null) {
                  prev = tree.get_prev_branch(b);
                  if (prev != null) {
                    tree.select_branch(prev);
                    return prev;
                  }
                }
              };
            }
          }
        }
      };
    }
  ]);

}).call(this);

'use strict';

angular.module('angularDjangoRegistrationAuthApp', ['ngCookies', 'ngResource', 'ngSanitize', 'ngRoute'])
.run(function(djangoAuth){
	djangoAuth.initialize('/api/rest-auth', false);
});

angular.module('angularDjangoRegistrationAuthApp')
  .service('djangoAuth', function djangoAuth($q, $http, $cookies, $rootScope) {
	// AngularJS will instantiate a singleton by calling "new" on this function
	var service = {
		/* START CUSTOMIZATION HERE */
		// Change this to point to your Django REST Auth API
		// e.g. /api/rest-auth  (DO NOT INCLUDE ENDING SLASH)
		'API_URL': '/api/rest-auth',
		// Set use_session to true to use Django sessions to store security token.
		// Set use_session to false to store the security token locally and transmit it as a custom header.
		'use_session': false,
		/* END OF CUSTOMIZATION */
		'authenticated': null,
		'authPromise': null,
		'request': function(args) {
			// Let's retrieve the token from the cookie, if available
			if(localStorage.token){
				$http.defaults.headers.common.Authorization = 'Token ' + localStorage.token;
			}
			// Continue
			params = args.params || {}
			args = args || {};
			var deferred = $q.defer(),
				url = this.API_URL + args.url,
				method = args.method || "GET",
				params = params,
				data = args.data || {};
			// Fire the request, as configured.
			$http({
				url: url,
				withCredentials: this.use_session,
				method: method.toUpperCase(),
				headers: {'X-CSRFToken': $cookies['csrftoken']},
				params: params,
				data: data
			})
			.success(angular.bind(this,function(data, status, headers, config) {
				deferred.resolve(data, status);
			}))
			.error(angular.bind(this,function(data, status, headers, config) {
				console.log("error syncing with: " + url);
				// Set request status
				if(data){
					data.status = status;
				}
				if(status == 0){
					if(data == ""){
						data = {};
						data['status'] = 0;
						data['non_field_errors'] = ["Could not connect. Please try again."];
					}
					// or if the data is null, then there was a timeout.
					if(data == null){
						// Inject a non field error alerting the user
						// that there's been a timeout error.
						data = {};
						data['status'] = 0;
						data['non_field_errors'] = ["Server timed out. Please try again."];
					}
				}
				deferred.reject(data, status, headers, config);
			}));
			return deferred.promise;
		},
		'register': function(username,password1,password2,email,more){
			var data = {
				'username':username,
				'password1':password1,
				'password2':password2,
				'email':email
			}
			data = angular.extend(data,more);
			return this.request({
				'method': "POST",
				'url': "/registration/",
				'data' :data
			});
		},
		'login': function(username,password){
			var djangoAuth = this;
			return this.request({
				'method': "POST",
				'url': "/login/",
				'data':{
					'username':username,
					'password':password
				}
			}).then(function(data){
				if(!djangoAuth.use_session){
					$http.defaults.headers.common.Authorization = 'Token ' + data.key;
					localStorage.token = data.key;
				}
				djangoAuth.authenticated = true;
				$rootScope.$broadcast("djangoAuth.logged_in", data);
			});
		},
		'logout': function(){
			var djangoAuth = this;
			return this.request({
				'method': "POST",
				'url': "/logout/"
			}).then(function(data){
				delete $http.defaults.headers.common.Authorization;
				delete localStorage.token;
				djangoAuth.authenticated = false;
				$rootScope.$broadcast("djangoAuth.logged_out");
			});
		},
		'changePassword': function(password1,password2){
			return this.request({
				'method': "POST",
				'url': "/password/change/",
				'data':{
					'new_password1':password1,
					'new_password2':password2
				}
			});
		},
		'resetPassword': function(email){
			return this.request({
				'method': "POST",
				'url': "/password/reset/",
				'data':{
					'email':email
				}
			});
		},
		'profile': function(){
			return this.request({
				'method': "GET",
				'url': "/user/"
			}); 
		},
		'updateProfile': function(data){
			return this.request({
				'method': "PATCH",
				'url': "/user/",
				'data':data
			}); 
		},
		'verify': function(key){
			return this.request({
				'method': "POST",
				'url': "/registration/verify-email/",
				'data': {'key': key} 
			});            
		},
		'confirmReset': function(uid,token,password1,password2){
			return this.request({
				'method': "POST",
				'url': "/password/reset/confirm/",
				'data':{
					'uid': uid,
					'token': token,
					'new_password1':password1,
					'new_password2':password2
				}
			});
		},
		'authenticationStatus': function(restrict, force){
			// Set restrict to true to reject the promise if not logged in
			// Set to false or omit to resolve when status is known
			// Set force to true to ignore stored value and query API
			restrict = restrict || false;
			force = force || false;
			if(this.authPromise == null || force){
				this.authPromise = this.request({
					'method': "GET",
					'url': "/user/"
				})
			}
			var da = this;
			var getAuthStatus = $q.defer();
			if(this.authenticated != null && !force){
				// We have a stored value which means we can pass it back right away.
				if(this.authenticated == false && restrict){
					getAuthStatus.reject("User is not logged in.");
				}else{
					getAuthStatus.resolve();
				}
			}else{
				// There isn't a stored value, or we're forcing a request back to
				// the API to get the authentication status.
				this.authPromise.then(function(){
					da.authenticated = true;
					getAuthStatus.resolve();
				},function(){
					da.authenticated = false;
					if(restrict){
						getAuthStatus.reject("User is not logged in.");
					}else{
						getAuthStatus.resolve();
					}
				});
			}
			return getAuthStatus.promise;
		},
		'initialize': function(url, sessions){
			this.API_URL = url;
			this.use_session = sessions;
			return this.authenticationStatus();
		}

	}
	return service;
  });

/**
 * @license
 * Fuse - Lightweight fuzzy-search
 *
 * Copyright (c) 2012-2016 Kirollos Risk <kirollos@gmail.com>.
 * All Rights Reserved. Apache Software License 2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
;(function (global) {
  'use strict'

  /** @type {function(...*)} */
  function log () {
    console.log.apply(console, arguments)
  }

  var defaultOptions = {
    // The name of the identifier property. If specified, the returned result will be a list
    // of the items' dentifiers, otherwise it will be a list of the items.
    id: null,

    // Indicates whether comparisons should be case sensitive.

    caseSensitive: false,

    // An array of values that should be included from the searcher's output. When this array
    // contains elements, each result in the list will be of the form `{ item: ..., include1: ..., include2: ... }`.
    // Values you can include are `score`, `matchedLocations`
    include: [],

    // Whether to sort the result list, by score
    shouldSort: true,

    // The search function to use
    // Note that the default search function ([[Function]]) must conform to the following API:
    //
    //  @param pattern The pattern string to search
    //  @param options The search option
    //  [[Function]].constructor = function(pattern, options)
    //
    //  @param text: the string to search in for the pattern
    //  @return Object in the form of:
    //    - isMatch: boolean
    //    - score: Int
    //  [[Function]].prototype.search = function(text)
    searchFn: BitapSearcher,

    // Default sort function
    sortFn: function (a, b) {
      return a.score - b.score
    },

    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: deepValue,

    // List of properties that will be searched. This also supports nested properties.
    keys: [],

    // Will print to the console. Useful for debugging.
    verbose: false,

    // When true, the search algorithm will search individual words **and** the full string,
    // computing the final score as a function of both. Note that when `tokenize` is `true`,
    // the `threshold`, `distance`, and `location` are inconsequential for individual tokens.
    tokenize: false,

    // When true, the result set will only include records that match all tokens. Will only work
    // if `tokenize` is also true.
    matchAllTokens: false,

    // Regex used to separate words when searching. Only applicable when `tokenize` is `true`.
    tokenSeparator: / +/g,

    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1,

    // When true, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    findAllMatches: false
  }

  /**
   * @constructor
   * @param {!Array} list
   * @param {!Object<string, *>} options
   */
  function Fuse (list, options) {
    var key

    this.list = list
    this.options = options = options || {}

    for (key in defaultOptions) {
      if (!defaultOptions.hasOwnProperty(key)) {
        continue;
      }
      // Add boolean type options
      if (typeof defaultOptions[key] === 'boolean') {
        this.options[key] = key in options ? options[key] : defaultOptions[key];
      // Add all other options
      } else {
        this.options[key] = options[key] || defaultOptions[key]
      }
    }
  }

  Fuse.VERSION = '2.6.2'

  /**
   * Sets a new list for Fuse to match against.
   * @param {!Array} list
   * @return {!Array} The newly set list
   * @public
   */
  Fuse.prototype.set = function (list) {
    this.list = list
    return list
  }

  Fuse.prototype.search = function (pattern) {
    if (this.options.verbose) log('\nSearch term:', pattern, '\n')

    this.pattern = pattern
    this.results = []
    this.resultMap = {}
    this._keyMap = null

    this._prepareSearchers()
    this._startSearch()
    this._computeScore()
    this._sort()

    var output = this._format()
    return output
  }

  Fuse.prototype._prepareSearchers = function () {
    var options = this.options
    var pattern = this.pattern
    var searchFn = options.searchFn
    var tokens = pattern.split(options.tokenSeparator)
    var i = 0
    var len = tokens.length

    if (this.options.tokenize) {
      this.tokenSearchers = []
      for (; i < len; i++) {
        this.tokenSearchers.push(new searchFn(tokens[i], options))
      }
    }
    this.fullSeacher = new searchFn(pattern, options)
  }

  Fuse.prototype._startSearch = function () {
    var options = this.options
    var getFn = options.getFn
    var list = this.list
    var listLen = list.length
    var keys = this.options.keys
    var keysLen = keys.length
    var key
    var weight
    var item = null
    var i
    var j

    // Check the first item in the list, if it's a string, then we assume
    // that every item in the list is also a string, and thus it's a flattened array.
    if (typeof list[0] === 'string') {
      // Iterate over every item
      for (i = 0; i < listLen; i++) {
        this._analyze('', list[i], i, i)
      }
    } else {
      this._keyMap = {}
      // Otherwise, the first item is an Object (hopefully), and thus the searching
      // is done on the values of the keys of each item.
      // Iterate over every item
      for (i = 0; i < listLen; i++) {
        item = list[i]
        // Iterate over every key
        for (j = 0; j < keysLen; j++) {
          key = keys[j]
          if (typeof key !== 'string') {
            weight = (1 - key.weight) || 1
            this._keyMap[key.name] = {
              weight: weight
            }
            if (key.weight <= 0 || key.weight > 1) {
              throw new Error('Key weight has to be > 0 and <= 1')
            }
            key = key.name
          } else {
            this._keyMap[key] = {
              weight: 1
            }
          }
          this._analyze(key, getFn(item, key, []), item, i)
        }
      }
    }
  }

  Fuse.prototype._analyze = function (key, text, entity, index) {
    var options = this.options
    var words
    var scores
    var exists = false
    var existingResult
    var averageScore
    var finalScore
    var scoresLen
    var mainSearchResult
    var tokenSearcher
    var termScores
    var word
    var tokenSearchResult
    var hasMatchInText
    var checkTextMatches
    var i
    var j

    // Check if the text can be searched
    if (text === undefined || text === null) {
      return
    }

    scores = []

    var numTextMatches = 0

    if (typeof text === 'string') {
      words = text.split(options.tokenSeparator)

      if (options.verbose) log('---------\nKey:', key)

      if (this.options.tokenize) {
        for (i = 0; i < this.tokenSearchers.length; i++) {
          tokenSearcher = this.tokenSearchers[i]

          if (options.verbose) log('Pattern:', tokenSearcher.pattern)

          termScores = []
          hasMatchInText = false

          for (j = 0; j < words.length; j++) {
            word = words[j]
            tokenSearchResult = tokenSearcher.search(word)
            var obj = {}
            if (tokenSearchResult.isMatch) {
              obj[word] = tokenSearchResult.score
              exists = true
              hasMatchInText = true
              scores.push(tokenSearchResult.score)
            } else {
              obj[word] = 1
              if (!this.options.matchAllTokens) {
                scores.push(1)
              }
            }
            termScores.push(obj)
          }

          if (hasMatchInText) {
            numTextMatches++
          }

          if (options.verbose) log('Token scores:', termScores)
        }

        averageScore = scores[0]
        scoresLen = scores.length
        for (i = 1; i < scoresLen; i++) {
          averageScore += scores[i]
        }
        averageScore = averageScore / scoresLen

        if (options.verbose) log('Token score average:', averageScore)
      }

      mainSearchResult = this.fullSeacher.search(text)
      if (options.verbose) log('Full text score:', mainSearchResult.score)

      finalScore = mainSearchResult.score
      if (averageScore !== undefined) {
        finalScore = (finalScore + averageScore) / 2
      }

      if (options.verbose) log('Score average:', finalScore)

      checkTextMatches = (this.options.tokenize && this.options.matchAllTokens) ? numTextMatches >= this.tokenSearchers.length : true

      if (options.verbose) log('Check Matches', checkTextMatches)

      // If a match is found, add the item to <rawResults>, including its score
      if ((exists || mainSearchResult.isMatch) && checkTextMatches) {
        // Check if the item already exists in our results
        existingResult = this.resultMap[index]

        if (existingResult) {
          // Use the lowest score
          // existingResult.score, bitapResult.score
          existingResult.output.push({
            key: key,
            score: finalScore,
            matchedIndices: mainSearchResult.matchedIndices
          })
        } else {
          // Add it to the raw result list
          this.resultMap[index] = {
            item: entity,
            output: [{
              key: key,
              score: finalScore,
              matchedIndices: mainSearchResult.matchedIndices
            }]
          }

          this.results.push(this.resultMap[index])
        }
      }
    } else if (isArray(text)) {
      for (i = 0; i < text.length; i++) {
        this._analyze(key, text[i], entity, index)
      }
    }
  }

  Fuse.prototype._computeScore = function () {
    var i
    var j
    var keyMap = this._keyMap
    var totalScore
    var output
    var scoreLen
    var score
    var weight
    var results = this.results
    var bestScore
    var nScore

    if (this.options.verbose) log('\n\nComputing score:\n')

    for (i = 0; i < results.length; i++) {
      totalScore = 0
      output = results[i].output
      scoreLen = output.length

      bestScore = 1

      for (j = 0; j < scoreLen; j++) {
        score = output[j].score
        weight = keyMap ? keyMap[output[j].key].weight : 1

        nScore = score * weight

        if (weight !== 1) {
          bestScore = Math.min(bestScore, nScore)
        } else {
          totalScore += nScore
          output[j].nScore = nScore
        }
      }

      if (bestScore === 1) {
        results[i].score = totalScore / scoreLen
      } else {
        results[i].score = bestScore
      }

      if (this.options.verbose) log(results[i])
    }
  }

  Fuse.prototype._sort = function () {
    var options = this.options
    if (options.shouldSort) {
      if (options.verbose) log('\n\nSorting....')
      this.results.sort(options.sortFn)
    }
  }

  Fuse.prototype._format = function () {
    var options = this.options
    var getFn = options.getFn
    var finalOutput = []
    var item
    var i
    var len
    var results = this.results
    var replaceValue
    var getItemAtIndex
    var include = options.include

    if (options.verbose) log('\n\nOutput:\n\n', results)

    // Helper function, here for speed-up, which replaces the item with its value,
    // if the options specifies it,
    replaceValue = options.id ? function (index) {
      results[index].item = getFn(results[index].item, options.id, [])[0]
    } : function () {}

    getItemAtIndex = function (index) {
      var record = results[index]
      var data
      var j
      var output
      var _item
      var _result

      // If `include` has values, put the item in the result
      if (include.length > 0) {
        data = {
          item: record.item
        }
        if (include.indexOf('matches') !== -1) {
          output = record.output
          data.matches = []
          for (j = 0; j < output.length; j++) {
            _item = output[j]
            _result = {
              indices: _item.matchedIndices
            }
            if (_item.key) {
              _result.key = _item.key
            }
            data.matches.push(_result)
          }
        }

        if (include.indexOf('score') !== -1) {
          data.score = results[index].score
        }

      } else {
        data = record.item
      }

      return data
    }

    // From the results, push into a new array only the item identifier (if specified)
    // of the entire item.  This is because we don't want to return the <results>,
    // since it contains other metadata
    for (i = 0, len = results.length; i < len; i++) {
      replaceValue(i)
      item = getItemAtIndex(i)
      finalOutput.push(item)
    }

    return finalOutput
  }

  // Helpers

  function deepValue (obj, path, list) {
    var firstSegment
    var remaining
    var dotIndex
    var value
    var i
    var len

    if (!path) {
      // If there's no path left, we've gotten to the object we care about.
      list.push(obj)
    } else {
      dotIndex = path.indexOf('.')

      if (dotIndex !== -1) {
        firstSegment = path.slice(0, dotIndex)
        remaining = path.slice(dotIndex + 1)
      } else {
        firstSegment = path
      }

      value = obj[firstSegment]
      if (value !== null && value !== undefined) {
        if (!remaining && (typeof value === 'string' || typeof value === 'number')) {
          list.push(value)
        } else if (isArray(value)) {
          // Search each item in the array.
          for (i = 0, len = value.length; i < len; i++) {
            deepValue(value[i], remaining, list)
          }
        } else if (remaining) {
          // An object. Recurse further.
          deepValue(value, remaining, list)
        }
      }
    }

    return list
  }

  function isArray (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]'
  }

  /**
   * Adapted from "Diff, Match and Patch", by Google
   *
   *   http://code.google.com/p/google-diff-match-patch/
   *
   * Modified by: Kirollos Risk <kirollos@gmail.com>
   * -----------------------------------------------
   * Details: the algorithm and structure was modified to allow the creation of
   * <Searcher> instances with a <search> method which does the actual
   * bitap search. The <pattern> (the string that is searched for) is only defined
   * once per instance and thus it eliminates redundant re-creation when searching
   * over a list of strings.
   *
   * Licensed under the Apache License, Version 2.0 (the "License")
   * you may not use this file except in compliance with the License.
   *
   * @constructor
   */
  function BitapSearcher (pattern, options) {
    options = options || {}
    this.options = options
    this.options.location = options.location || BitapSearcher.defaultOptions.location
    this.options.distance = 'distance' in options ? options.distance : BitapSearcher.defaultOptions.distance
    this.options.threshold = 'threshold' in options ? options.threshold : BitapSearcher.defaultOptions.threshold
    this.options.maxPatternLength = options.maxPatternLength || BitapSearcher.defaultOptions.maxPatternLength

    this.pattern = options.caseSensitive ? pattern : pattern.toLowerCase()
    this.patternLen = pattern.length

    if (this.patternLen <= this.options.maxPatternLength) {
      this.matchmask = 1 << (this.patternLen - 1)
      this.patternAlphabet = this._calculatePatternAlphabet()
    }
  }

  BitapSearcher.defaultOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,

    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100,

    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,

    // Machine word size
    maxPatternLength: 32
  }

  /**
   * Initialize the alphabet for the Bitap algorithm.
   * @return {Object} Hash of character locations.
   * @private
   */
  BitapSearcher.prototype._calculatePatternAlphabet = function () {
    var mask = {},
      i = 0

    for (i = 0; i < this.patternLen; i++) {
      mask[this.pattern.charAt(i)] = 0
    }

    for (i = 0; i < this.patternLen; i++) {
      mask[this.pattern.charAt(i)] |= 1 << (this.pattern.length - i - 1)
    }

    return mask
  }

  /**
   * Compute and return the score for a match with `e` errors and `x` location.
   * @param {number} errors Number of errors in match.
   * @param {number} location Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  BitapSearcher.prototype._bitapScore = function (errors, location) {
    var accuracy = errors / this.patternLen,
      proximity = Math.abs(this.options.location - location)

    if (!this.options.distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy
    }
    return accuracy + (proximity / this.options.distance)
  }

  /**
   * Compute and return the result of the search
   * @param {string} text The text to search in
   * @return {{isMatch: boolean, score: number}} Literal containing:
   *                          isMatch - Whether the text is a match or not
   *                          score - Overall score for the match
   * @public
   */
  BitapSearcher.prototype.search = function (text) {
    var options = this.options
    var i
    var j
    var textLen
    var findAllMatches
    var location
    var threshold
    var bestLoc
    var binMin
    var binMid
    var binMax
    var start, finish
    var bitArr
    var lastBitArr
    var charMatch
    var score
    var locations
    var matches
    var isMatched
    var matchMask
    var matchedIndices
    var matchesLen
    var match

    text = options.caseSensitive ? text : text.toLowerCase()

    if (this.pattern === text) {
      // Exact match
      return {
        isMatch: true,
        score: 0,
        matchedIndices: [[0, text.length - 1]]
      }
    }

    // When pattern length is greater than the machine word length, just do a a regex comparison
    if (this.patternLen > options.maxPatternLength) {
      matches = text.match(new RegExp(this.pattern.replace(options.tokenSeparator, '|')))
      isMatched = !!matches

      if (isMatched) {
        matchedIndices = []
        for (i = 0, matchesLen = matches.length; i < matchesLen; i++) {
          match = matches[i]
          matchedIndices.push([text.indexOf(match), match.length - 1])
        }
      }

      return {
        isMatch: isMatched,
        // TODO: revisit this score
        score: isMatched ? 0.5 : 1,
        matchedIndices: matchedIndices
      }
    }

    findAllMatches = options.findAllMatches

    location = options.location
    // Set starting location at beginning text and initialize the alphabet.
    textLen = text.length
    // Highest score beyond which we give up.
    threshold = options.threshold
    // Is there a nearby exact match? (speedup)
    bestLoc = text.indexOf(this.pattern, location)

    // a mask of the matches
    matchMask = []
    for (i = 0; i < textLen; i++) {
      matchMask[i] = 0
    }

    if (bestLoc != -1) {
      threshold = Math.min(this._bitapScore(0, bestLoc), threshold)
      // What about in the other direction? (speed up)
      bestLoc = text.lastIndexOf(this.pattern, location + this.patternLen)

      if (bestLoc != -1) {
        threshold = Math.min(this._bitapScore(0, bestLoc), threshold)
      }
    }

    bestLoc = -1
    score = 1
    locations = []
    binMax = this.patternLen + textLen

    for (i = 0; i < this.patternLen; i++) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from the match location we can stray
      // at this error level.
      binMin = 0
      binMid = binMax
      while (binMin < binMid) {
        if (this._bitapScore(i, location + binMid) <= threshold) {
          binMin = binMid
        } else {
          binMax = binMid
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin)
      }

      // Use the result from this iteration as the maximum for the next.
      binMax = binMid
      start = Math.max(1, location - binMid + 1)
      if (findAllMatches) {
        finish = textLen;
      } else {
        finish = Math.min(location + binMid, textLen) + this.patternLen
      }

      // Initialize the bit array
      bitArr = Array(finish + 2)

      bitArr[finish + 1] = (1 << i) - 1

      for (j = finish; j >= start; j--) {
        charMatch = this.patternAlphabet[text.charAt(j - 1)]

        if (charMatch) {
          matchMask[j - 1] = 1
        }

        if (i === 0) {
          // First pass: exact match.
          bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch
        } else {
          // Subsequent passes: fuzzy match.
          bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch | (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1]
        }
        if (bitArr[j] & this.matchmask) {
          score = this._bitapScore(i, j - 1)

          // This match will almost certainly be better than any existing match.
          // But check anyway.
          if (score <= threshold) {
            // Indeed it is
            threshold = score
            bestLoc = j - 1
            locations.push(bestLoc)

            if (bestLoc > location) {
              // When passing loc, don't exceed our current distance from loc.
              start = Math.max(1, 2 * location - bestLoc)
            } else {
              // Already passed loc, downhill from here on in.
              break
            }
          }
        }
      }

      // No hope for a (better) match at greater error levels.
      if (this._bitapScore(i + 1, location) > threshold) {
        break
      }
      lastBitArr = bitArr
    }

    matchedIndices = this._getMatchedIndices(matchMask)

    // Count exact matches (those with a score of 0) to be "almost" exact
    return {
      isMatch: bestLoc >= 0,
      score: score === 0 ? 0.001 : score,
      matchedIndices: matchedIndices
    }
  }

  BitapSearcher.prototype._getMatchedIndices = function (matchMask) {
    var matchedIndices = []
    var start = -1
    var end = -1
    var i = 0
    var match
    var len = matchMask.length
    for (; i < len; i++) {
      match = matchMask[i]
      if (match && start === -1) {
        start = i
      } else if (!match && start !== -1) {
        end = i - 1
        if ((end - start) + 1 >= this.options.minMatchCharLength) {
            matchedIndices.push([start, end])
        }
        start = -1
      }
    }
    if (matchMask[i - 1]) {
      if ((i-1 - start) + 1 >= this.options.minMatchCharLength) {
        matchedIndices.push([start, i - 1])
      }
    }
    return matchedIndices
  }

  // Export to Common JS Loader
  if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = Fuse
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(function () {
      return Fuse
    })
  } else {
    // Browser globals (root is window)
    global.Fuse = Fuse
  }

})(this);

/*!
 * ngTagsInput v3.0.0
 * http://mbenford.github.io/ngTagsInput
 *
 * Copyright (c) 2013-2015 Michael Benford
 * License: MIT
 *
 * Generated at 2015-07-13 02:08:11 -0300
 */
(function() {
'use strict';

var KEYS = {
    backspace: 8,
    tab: 9,
    enter: 13,
    escape: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    delete: 46,
    comma: 188
};

var MAX_SAFE_INTEGER = 9007199254740991;
var SUPPORTED_INPUT_TYPES = ['text', 'email', 'url'];

var tagsInput = angular.module('ngTagsInput', []);

/**
 * @ngdoc directive
 * @name tagsInput
 * @module ngTagsInput
 *
 * @description
 * Renders an input box with tag editing support.
 *
 * @param {string} ngModel Assignable Angular expression to data-bind to.
 * @param {string=} [template=NA] URL or id of a custom template for rendering each tag.
 * @param {string=} [displayProperty=text] Property to be rendered as the tag label.
 * @param {string=} [keyProperty=text] Property to be used as a unique identifier for the tag.
 * @param {string=} [type=text] Type of the input element. Only 'text', 'email' and 'url' are supported values.
 * @param {string=} [text=NA] Assignable Angular expression for data-binding to the element's text.
 * @param {number=} tabindex Tab order of the control.
 * @param {string=} [placeholder=Add a tag] Placeholder text for the control.
 * @param {number=} [minLength=3] Minimum length for a new tag.
 * @param {number=} [maxLength=MAX_SAFE_INTEGER] Maximum length allowed for a new tag.
 * @param {number=} [minTags=0] Sets minTags validation error key if the number of tags added is less than minTags.
 * @param {number=} [maxTags=MAX_SAFE_INTEGER] Sets maxTags validation error key if the number of tags added is greater
 *    than maxTags.
 * @param {boolean=} [allowLeftoverText=false] Sets leftoverText validation error key if there is any leftover text in
 *    the input element when the directive loses focus.
 * @param {string=} [removeTagSymbol=×] (Obsolete) Symbol character for the remove tag button.
 * @param {boolean=} [addOnEnter=true] Flag indicating that a new tag will be added on pressing the ENTER key.
 * @param {boolean=} [addOnSpace=false] Flag indicating that a new tag will be added on pressing the SPACE key.
 * @param {boolean=} [addOnComma=true] Flag indicating that a new tag will be added on pressing the COMMA key.
 * @param {boolean=} [addOnBlur=true] Flag indicating that a new tag will be added when the input field loses focus.
 * @param {boolean=} [addOnPaste=false] Flag indicating that the text pasted into the input field will be split into tags.
 * @param {string=} [pasteSplitPattern=,] Regular expression used to split the pasted text into tags.
 * @param {boolean=} [replaceSpacesWithDashes=true] Flag indicating that spaces will be replaced with dashes.
 * @param {string=} [allowedTagsPattern=.+] Regular expression that determines whether a new tag is valid.
 * @param {boolean=} [enableEditingLastTag=false] Flag indicating that the last tag will be moved back into the new tag
 *    input box instead of being removed when the backspace key is pressed and the input box is empty.
 * @param {boolean=} [addFromAutocompleteOnly=false] Flag indicating that only tags coming from the autocomplete list
 *    will be allowed. When this flag is true, addOnEnter, addOnComma, addOnSpace and addOnBlur values are ignored.
 * @param {boolean=} [spellcheck=true] Flag indicating whether the browser's spellcheck is enabled for the input field or not.
 * @param {expression=} [onTagAdding=NA] Expression to evaluate that will be invoked before adding a new tag. The new
 *    tag is available as $tag. This method must return either true or false. If false, the tag will not be added.
 * @param {expression=} [onTagAdded=NA] Expression to evaluate upon adding a new tag. The new tag is available as $tag.
 * @param {expression=} [onInvalidTag=NA] Expression to evaluate when a tag is invalid. The invalid tag is available as $tag.
 * @param {expression=} [onTagRemoving=NA] Expression to evaluate that will be invoked before removing a tag. The tag
 *    is available as $tag. This method must return either true or false. If false, the tag will not be removed.
 * @param {expression=} [onTagRemoved=NA] Expression to evaluate upon removing an existing tag. The removed tag is
 *    available as $tag.
 * @param {expression=} [onTagClicked=NA] Expression to evaluate upon clicking an existing tag. The clicked tag is available as $tag.
 */
tagsInput.directive('tagsInput', ["$timeout", "$document", "$window", "tagsInputConfig", "tiUtil", function($timeout, $document, $window, tagsInputConfig, tiUtil) {
    function TagList(options, events, onTagAdding, onTagRemoving) {
        var self = {}, getTagText, setTagText, tagIsValid;

        getTagText = function(tag) {
            return tiUtil.safeToString(tag[options.displayProperty]);
        };

        setTagText = function(tag, text) {
            tag[options.displayProperty] = text;
        };

        tagIsValid = function(tag) {
            var tagText = getTagText(tag);

            return tagText &&
                   tagText.length >= options.minLength &&
                   tagText.length <= options.maxLength &&
                   options.allowedTagsPattern.test(tagText) &&
                   !tiUtil.findInObjectArray(self.items, tag, options.keyProperty || options.displayProperty) &&
                   onTagAdding({ $tag: tag });
        };

        self.items = [];

        self.addText = function(text) {
            var tag = {};
            setTagText(tag, text);
            return self.add(tag);
        };

        self.add = function(tag) {
            var tagText = getTagText(tag);

            if (options.replaceSpacesWithDashes) {
                tagText = tiUtil.replaceSpacesWithDashes(tagText);
            }

            setTagText(tag, tagText);

            if (tagIsValid(tag)) {
                self.items.push(tag);
                events.trigger('tag-added', { $tag: tag });
            }
            else if (tagText) {
                events.trigger('invalid-tag', { $tag: tag });
            }

            return tag;
        };

        self.remove = function(index) {
            var tag = self.items[index];

            if (onTagRemoving({ $tag: tag }))  {
                self.items.splice(index, 1);
                self.clearSelection();
                events.trigger('tag-removed', { $tag: tag });
                return tag;
            }
        };

        self.select = function(index) {
            if (index < 0) {
                index = self.items.length - 1;
            }
            else if (index >= self.items.length) {
                index = 0;
            }

            self.index = index;
            self.selected = self.items[index];
        };

        self.selectPrior = function() {
            self.select(--self.index);
        };

        self.selectNext = function() {
            self.select(++self.index);
        };

        self.removeSelected = function() {
            return self.remove(self.index);
        };

        self.clearSelection = function() {
            self.selected = null;
            self.index = -1;
        };

        self.clearSelection();

        return self;
    }

    function validateType(type) {
        return SUPPORTED_INPUT_TYPES.indexOf(type) !== -1;
    }

    return {
        restrict: 'E',
        require: 'ngModel',
        scope: {
            tags: '=ngModel',
            text: '=?',
            onTagAdding: '&',
            onTagAdded: '&',
            onInvalidTag: '&',
            onTagRemoving: '&',
            onTagRemoved: '&',
            onTagClicked: '&',
            attributeList: '='
        },
        replace: false,
        transclude: true,
        templateUrl: 'ngTagsInput/tags-input.html',
        controller: ["$scope", "$attrs", "$element", function($scope, $attrs, $element) {
            $scope.events = tiUtil.simplePubSub();

            tagsInputConfig.load('tagsInput', $scope, $attrs, {
                template: [String, 'ngTagsInput/tag-item.html'],
                type: [String, 'text', validateType],
                placeholder: [String, 'Add a tag'],
                tabindex: [Number, null],
                removeTagSymbol: [String, String.fromCharCode(215)],
                replaceSpacesWithDashes: [Boolean, true],
                minLength: [Number, 3],
                maxLength: [Number, MAX_SAFE_INTEGER],
                addOnEnter: [Boolean, true],
                addOnSpace: [Boolean, false],
                addOnComma: [Boolean, true],
                addOnBlur: [Boolean, true],
                addOnPaste: [Boolean, false],
                pasteSplitPattern: [RegExp, /,/],
                allowedTagsPattern: [RegExp, /.+/],
                enableEditingLastTag: [Boolean, false],
                minTags: [Number, 0],
                maxTags: [Number, MAX_SAFE_INTEGER],
                displayProperty: [String, 'text'],
                keyProperty: [String, ''],
                allowLeftoverText: [Boolean, false],
                addFromAutocompleteOnly: [Boolean, false],
                spellcheck: [Boolean, true]
            });

            $scope.tagList = new TagList($scope.options, $scope.events,
                tiUtil.handleUndefinedResult($scope.onTagAdding, true),
                tiUtil.handleUndefinedResult($scope.onTagRemoving, true));

            this.registerAutocomplete = function() {
                var input = $element.find('input');

                return {
                    addTag: function(tag) {
                        return $scope.tagList.add(tag);
                    },
                    focusInput: function() {
                        input[0].focus();
                    },
                    getTags: function() {
                        return $scope.tagList.items;
                    },
                    getCurrentTagText: function() {
                        return $scope.newTag.text();
                    },
                    getOptions: function() {
                        return $scope.options;
                    },
                    on: function(name, handler) {
                        $scope.events.on(name, handler);
                        return this;
                    }
                };
            };

            this.registerTagItem = function() {
                return {
                    getOptions: function() {
                        return $scope.options;
                    },
                    removeTag: function(index) {
                        if ($scope.disabled) {
                            return;
                        }
                        $scope.tagList.remove(index);
                    }
                };
            };
        }],
        link: function(scope, element, attrs, ngModelCtrl) {
            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace, KEYS.delete, KEYS.left, KEYS.right],
                tagList = scope.tagList,
                events = scope.events,
                options = scope.options,
                input = element.find('input'),
                validationOptions = ['minTags', 'maxTags', 'allowLeftoverText'],
                setElementValidity;

            setElementValidity = function() {
                ngModelCtrl.$setValidity('maxTags', tagList.items.length <= options.maxTags);
                ngModelCtrl.$setValidity('minTags', tagList.items.length >= options.minTags);
                ngModelCtrl.$setValidity('leftoverText', scope.hasFocus || options.allowLeftoverText ? true : !scope.newTag.text());
            };

            ngModelCtrl.$isEmpty = function(value) {
                return !value || !value.length;
            };

            scope.newTag = {
                text: function(value) {
                    if (angular.isDefined(value)) {
                        scope.text = value;
                        events.trigger('input-change', value);
                    }
                    else {
                        return scope.text || '';
                    }
                },
                invalid: null
            };

            scope.track = function(tag) {
                return tag[options.keyProperty || options.displayProperty];
            };

            scope.$watch('tags', function(value) {
                if (value) {
                    tagList.items = tiUtil.makeObjectArray(value, options.displayProperty);
                    scope.tags = tagList.items;
                }
                else {
                    tagList.items = [];
                }
            });

            scope.$watch('tags.length', function() {
                setElementValidity();

                // ngModelController won't trigger validators when the model changes (because it's an array),
                // so we need to do it ourselves. Unfortunately this won't trigger any registered formatter.
                ngModelCtrl.$validate();
            });

            attrs.$observe('disabled', function(value) {
                scope.disabled = value;
            });

            scope.eventHandlers = {
                input: {
                    keydown: function($event) {
                        events.trigger('input-keydown', $event);
                    },
                    focus: function() {
                        if (scope.hasFocus) {
                            return;
                        }

                        scope.hasFocus = true;
                        events.trigger('input-focus');
                    },
                    blur: function() {
                        $timeout(function() {
                            var activeElement = $document.prop('activeElement'),
                                lostFocusToBrowserWindow = activeElement === input[0],
                                lostFocusToChildElement = element[0].contains(activeElement);

                            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {
                                scope.hasFocus = false;
                                events.trigger('input-blur');
                            }
                        });
                    },
                    paste: function($event) {
                        $event.getTextData = function() {
                            var clipboardData = $event.clipboardData || ($event.originalEvent && $event.originalEvent.clipboardData);
                            return clipboardData ? clipboardData.getData('text/plain') : $window.clipboardData.getData('Text');
                        };
                        events.trigger('input-paste', $event);
                    }
                },
                host: {
                    click: function() {
                        if (scope.disabled) {
                            return;
                        }
                        input[0].focus();
                    }
                },
                tag: {
                    click: function(tag) {
                        events.trigger('tag-clicked', { $tag: tag });
                    }
                }
            };

            events
                .on('tag-added', scope.onTagAdded)
                .on('invalid-tag', scope.onInvalidTag)
                .on('tag-removed', scope.onTagRemoved)
                .on('tag-clicked', scope.onTagClicked)
                .on('tag-added', function() {
                    scope.newTag.text('');
                })
                .on('tag-added tag-removed', function() {
                    scope.tags = tagList.items;
                    // Ideally we should be able call $setViewValue here and let it in turn call $setDirty and $validate
                    // automatically, but since the model is an array, $setViewValue does nothing and it's up to us to do it.
                    // Unfortunately this won't trigger any registered $parser and there's no safe way to do it.
                    ngModelCtrl.$setDirty();
                })
                .on('invalid-tag', function() {
                    scope.newTag.invalid = true;
                })
                .on('option-change', function(e) {
                    if (validationOptions.indexOf(e.name) !== -1) {
                        setElementValidity();
                    }
                })
                .on('input-change', function() {
                    tagList.clearSelection();
                    scope.newTag.invalid = null;
                })
                .on('input-focus', function() {
                    element.triggerHandler('focus');
                    ngModelCtrl.$setValidity('leftoverText', true);
                })
                .on('input-blur', function() {
                    if (options.addOnBlur && !options.addFromAutocompleteOnly) {
                        tagList.addText(scope.newTag.text());
                    }
                    element.triggerHandler('blur');
                    setElementValidity();
                })
                .on('input-keydown', function(event) {
                    var key = event.keyCode,
                        addKeys = {},
                        shouldAdd, shouldRemove, shouldSelect, shouldEditLastTag;

                    if (tiUtil.isModifierOn(event) || hotkeys.indexOf(key) === -1) {
                        return;
                    }

                    addKeys[KEYS.enter] = options.addOnEnter;
                    addKeys[KEYS.comma] = options.addOnComma;
                    addKeys[KEYS.space] = options.addOnSpace;

                    shouldAdd = !options.addFromAutocompleteOnly && addKeys[key];
                    shouldRemove = (key === KEYS.backspace || key === KEYS.delete) && tagList.selected;
                    shouldEditLastTag = key === KEYS.backspace && scope.newTag.text().length === 0 && options.enableEditingLastTag;
                    shouldSelect = (key === KEYS.backspace || key === KEYS.left || key === KEYS.right) && scope.newTag.text().length === 0 && !options.enableEditingLastTag;

                    if (shouldAdd) {
                        tagList.addText(scope.newTag.text());
                    }
                    else if (shouldEditLastTag) {
                        var tag;

                        tagList.selectPrior();
                        tag = tagList.removeSelected();

                        if (tag) {
                            scope.newTag.text(tag[options.displayProperty]);
                        }
                    }
                    else if (shouldRemove) {
                        tagList.removeSelected();
                    }
                    else if (shouldSelect) {
                        if (key === KEYS.left || key === KEYS.backspace) {
                            tagList.selectPrior();
                        }
                        else if (key === KEYS.right) {
                            tagList.selectNext();
                        }
                    }

                    if (shouldAdd || shouldSelect || shouldRemove || shouldEditLastTag) {
                        event.preventDefault();
                    }
                })
                .on('input-paste', function(event) {
                    if (options.addOnPaste) {
                        var data = event.getTextData();
                        var tags = data.split(options.pasteSplitPattern);

                        if (tags.length > 1) {
                            tags.forEach(function(tag) {
                                tagList.addText(tag);
                            });
                            event.preventDefault();
                        }
                    }
                });
        }
    };
}]);


/**
 * @ngdoc directive
 * @name tiTagItem
 * @module ngTagsInput
 *
 * @description
 * Represents a tag item. Used internally by the tagsInput directive.
 */
tagsInput.directive('tiTagItem', ["tiUtil", function(tiUtil) {
    return {
        restrict: 'E',
        require: '^tagsInput',
        template: '<ng-include src="$$template"></ng-include>',
        scope: { data: '=' },
        link: function(scope, element, attrs, tagsInputCtrl) {
            var tagsInput = tagsInputCtrl.registerTagItem(),
                options = tagsInput.getOptions();

            scope.$$template = options.template;
            scope.$$removeTagSymbol = options.removeTagSymbol;
            scope.$getDisplayText = function() {
                return tiUtil.safeToString(scope.data[options.displayProperty]);
            };
            scope.$removeTag = function() {
                tagsInput.removeTag(scope.$index);
            };

            scope.$watch('$parent.$index', function(value) {
                scope.$index = value;
            });
        }
    };
}]);


/**
 * @ngdoc directive
 * @name autoComplete
 * @module ngTagsInput
 *
 * @description
 * Provides autocomplete support for the tagsInput directive.
 *
 * @param {expression} source Expression to evaluate upon changing the input content. The input value is available as
 *    $query. The result of the expression must be a promise that eventually resolves to an array of strings.
 * @param {string=} [template=NA] URL or id of a custom template for rendering each element of the autocomplete list.
 * @param {string=} [displayProperty=tagsInput.displayText] Property to be rendered as the autocomplete label.
 * @param {number=} [debounceDelay=100] Amount of time, in milliseconds, to wait before evaluating the expression in
 *    the source option after the last keystroke.
 * @param {number=} [minLength=3] Minimum number of characters that must be entered before evaluating the expression
 *    in the source option.
 * @param {boolean=} [highlightMatchedText=true] Flag indicating that the matched text will be highlighted in the
 *    suggestions list.
 * @param {number=} [maxResultsToShow=10] Maximum number of results to be displayed at a time.
 * @param {boolean=} [loadOnDownArrow=false] Flag indicating that the source option will be evaluated when the down arrow
 *    key is pressed and the suggestion list is closed. The current input value is available as $query.
 * @param {boolean=} [loadOnEmpty=false] Flag indicating that the source option will be evaluated when the input content
 *    becomes empty. The $query variable will be passed to the expression as an empty string.
 * @param {boolean=} [loadOnFocus=false] Flag indicating that the source option will be evaluated when the input element
 *    gains focus. The current input value is available as $query.
 * @param {boolean=} [selectFirstMatch=true] Flag indicating that the first match will be automatically selected once
 *    the suggestion list is shown.
 */
tagsInput.directive('autoComplete', ["$document", "$timeout", "$sce", "$q", "tagsInputConfig", "tiUtil", function($document, $timeout, $sce, $q, tagsInputConfig, tiUtil) {
    function SuggestionList(loadFn, options, events) {
        var self = {}, getDifference, lastPromise, getTagId;

        getTagId = function() {
            return options.tagsInput.keyProperty || options.tagsInput.displayProperty;
        };

        getDifference = function(array1, array2) {
            return array1.filter(function(item) {
                return !tiUtil.findInObjectArray(array2, item, getTagId(), function(a, b) {
                    if (options.tagsInput.replaceSpacesWithDashes) {
                        a = tiUtil.replaceSpacesWithDashes(a);
                        b = tiUtil.replaceSpacesWithDashes(b);
                    }
                    return tiUtil.defaultComparer(a, b);
                });
            });
        };

        self.reset = function() {
            lastPromise = null;

            self.items = [];
            self.visible = false;
            self.index = -1;
            self.selected = null;
            self.query = null;
        };
        self.show = function() {
            if (options.selectFirstMatch) {
                self.select(0);
            }
            else {
                self.selected = null;
            }
            self.visible = true;
        };
        self.load = tiUtil.debounce(function(query, tags) {
            self.query = query;

            var promise = $q.when(loadFn({ $query: query }));
            lastPromise = promise;

            promise.then(function(items) {
                if (promise !== lastPromise) {
                    return;
                }

                items = tiUtil.makeObjectArray(items.data || items, getTagId());
                items = getDifference(items, tags);
                self.items = items.slice(0, options.maxResultsToShow);

                if (self.items.length > 0) {
                    self.show();
                }
                else {
                    self.reset();
                    self.visible = true;
                }
            });
        }, options.debounceDelay);

        self.selectNext = function() {
            self.select(++self.index);
        };
        self.selectPrior = function() {
            self.select(--self.index);
        };
        self.select = function(index) {
            if (index < 0) {
                index = self.items.length - 1;
            }
            else if (index >= self.items.length) {
                index = 0;
            }
            self.index = index;
            self.selected = self.items[index];
            events.trigger('suggestion-selected', index);
        };

        self.reset();

        return self;
    }

    function scrollToElement(root, index) {
        var element = root.find('li').eq(index),
            parent = element.parent(),
            elementTop = element.prop('offsetTop'),
            elementHeight = element.prop('offsetHeight'),
            parentHeight = parent.prop('clientHeight'),
            parentScrollTop = parent.prop('scrollTop');

        if (elementTop < parentScrollTop) {
            parent.prop('scrollTop', elementTop);
        }
        else if (elementTop + elementHeight > parentHeight + parentScrollTop) {
            parent.prop('scrollTop', elementTop + elementHeight - parentHeight);
        }
    }

    return {
        restrict: 'E',
        require: '^tagsInput',
        scope: { 
            source: '&', 
            filter: '=',
            attributeList: '='
        },
        templateUrl: 'ngTagsInput/auto-complete.html',
        controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
            $scope.events = tiUtil.simplePubSub();

            tagsInputConfig.load('autoComplete', $scope, $attrs, {
                template: [String, 'ngTagsInput/auto-complete-match.html'],
                debounceDelay: [Number, 100],
                minLength: [Number, 3],
                highlightMatchedText: [Boolean, true],
                maxResultsToShow: [Number, 10],
                loadOnDownArrow: [Boolean, false],
                loadOnEmpty: [Boolean, false],
                loadOnFocus: [Boolean, false],
                selectFirstMatch: [Boolean, true],
                displayProperty: [String, '']
            });

            $scope.suggestionList = new SuggestionList($scope.source, $scope.options, $scope.events);

            this.registerAutocompleteMatch = function() {
                return {
                    getOptions: function() {
                        return $scope.options;
                    },
                    getQuery: function() {
                        return $scope.suggestionList.query;
                    }
                };
            };
        }],
        link: function(scope, element, attrs, tagsInputCtrl) {
            var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],
                suggestionList = scope.suggestionList,
                tagsInput = tagsInputCtrl.registerAutocomplete(),
                options = scope.options,
                events = scope.events,
                shouldLoadSuggestions;

            options.tagsInput = tagsInput.getOptions();

            shouldLoadSuggestions = function(value) {
                return value && value.length >= options.minLength || !value && options.loadOnEmpty;
            };

            scope.addSuggestionByIndex = function(index) {
                suggestionList.select(index);
                scope.addSuggestion();
            };

            scope.addSuggestion = function() {
                var added = false;

                if (suggestionList.selected) {
                    suggestionList.selected.text = '\'' + suggestionList.selected.text + '\'';
                    tagsInput.addTag(angular.copy(suggestionList.selected));
                    suggestionList.reset();
                    tagsInput.focusInput();

                    added = true;
                }
                return added;
            };

            scope.track = function(item) {
                return item[options.tagsInput.keyProperty || options.tagsInput.displayProperty];
            };

            tagsInput
                .on('tag-added tag-removed invalid-tag input-blur', function() {
                    suggestionList.reset();
                })
                .on('input-change', function(value) {
                    if (shouldLoadSuggestions(value)) {
                        suggestionList.load(value, tagsInput.getTags());
                    }
                    else {
                        suggestionList.reset();
                    }
                })
                .on('input-focus', function() {
                    var value = tagsInput.getCurrentTagText();
                    if (options.loadOnFocus && shouldLoadSuggestions(value)) {
                        suggestionList.load(value, tagsInput.getTags());
                    }
                })
                .on('input-keydown', function(event) {
                    var key = event.keyCode,
                        handled = false;

                    if (tiUtil.isModifierOn(event) || hotkeys.indexOf(key) === -1) {
                        return;
                    }

                    if (suggestionList.visible) {

                        if (key === KEYS.down) {
                            suggestionList.selectNext();
                            handled = true;
                        }
                        else if (key === KEYS.up) {
                            suggestionList.selectPrior();
                            handled = true;
                        }
                        else if (key === KEYS.escape) {
                            suggestionList.reset();
                            handled = true;
                        }
                        else if (key === KEYS.enter || key === KEYS.tab) {
                            handled = scope.addSuggestion();
                        }
                    }
                    else {
                        if (key === KEYS.down && scope.options.loadOnDownArrow) {
                            suggestionList.load(tagsInput.getCurrentTagText(), tagsInput.getTags());
                            handled = true;
                        }
                    }

                    if (handled) {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            events.on('suggestion-selected', function(index) {
                scrollToElement(element, index);
            });

            var initializing = true;
            scope.$watch('filter.selected', function() {
                if (initializing) {
                    $timeout(function() { initializing = false; });
                } else {
                    $timeout(function() {
                        suggestionList.load(tagsInput.getCurrentTagText(), tagsInput.getTags());
                    });
                }
            });
        }
    };
}]);


/**
 * @ngdoc directive
 * @name tiAutocompleteMatch
 * @module ngTagsInput
 *
 * @description
 * Represents an autocomplete match. Used internally by the autoComplete directive.
 */
tagsInput.directive('tiAutocompleteMatch', ["$sce", "tiUtil", function($sce, tiUtil) {
    return {
        restrict: 'E',
        require: '^autoComplete',
        template: '<ng-include src="$$template"></ng-include>',
        scope: { data: '=' },
        link: function(scope, element, attrs, autoCompleteCtrl) {
            var autoComplete = autoCompleteCtrl.registerAutocompleteMatch(),
                options = autoComplete.getOptions();

            scope.$$template = options.template;
            scope.$index = scope.$parent.$index;

            scope.$highlight = function(text) {
                if (options.highlightMatchedText) {
                    text = tiUtil.safeHighlight(text, autoComplete.getQuery());
                }
                return $sce.trustAsHtml(text);
            };
            scope.$getDisplayText =  function() {
                return tiUtil.safeToString(scope.data[options.displayProperty || options.tagsInput.displayProperty]);
            };
        }
    };
}]);


/**
 * @ngdoc directive
 * @name tiTranscludeAppend
 * @module ngTagsInput
 *
 * @description
 * Re-creates the old behavior of ng-transclude. Used internally by tagsInput directive.
 */
tagsInput.directive('tiTranscludeAppend', function() {
    return function(scope, element, attrs, ctrl, transcludeFn) {
        transcludeFn(function(clone) {
            element.append(clone);
        });
    };
});

/**
 * @ngdoc directive
 * @name tiAutosize
 * @module ngTagsInput
 *
 * @description
 * Automatically sets the input's width so its content is always visible. Used internally by tagsInput directive.
 */
tagsInput.directive('tiAutosize', ["tagsInputConfig", function(tagsInputConfig) {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attrs, ctrl) {
            var threshold = tagsInputConfig.getTextAutosizeThreshold(),
                span, resize;

            span = angular.element('<span class="input"></span>');
            span.css('display', 'none')
                .css('visibility', 'hidden')
                .css('width', 'auto')
                .css('white-space', 'pre');

            element.parent().append(span);

            resize = function(originalValue) {
                var value = originalValue, width;

                if (angular.isString(value) && value.length === 0) {
                    value = attrs.placeholder;
                }

                if (value) {
                    span.text(value);
                    span.css('display', '');
                    width = span.prop('offsetWidth');
                    span.css('display', 'none');
                }

                element.css('width', width ? width + threshold + 'px' : '');

                return originalValue;
            };

            ctrl.$parsers.unshift(resize);
            ctrl.$formatters.unshift(resize);

            attrs.$observe('placeholder', function(value) {
                if (!ctrl.$modelValue) {
                    resize(value);
                }
            });
        }
    };
}]);

/**
 * @ngdoc directive
 * @name tiBindAttrs
 * @module ngTagsInput
 *
 * @description
 * Binds attributes to expressions. Used internally by tagsInput directive.
 */
tagsInput.directive('tiBindAttrs', function() {
    return function(scope, element, attrs) {
        scope.$watch(attrs.tiBindAttrs, function(value) {
            angular.forEach(value, function(value, key) {
                attrs.$set(key, value);
            });
        }, true);
    };
});

/**
 * @ngdoc service
 * @name tagsInputConfig
 * @module ngTagsInput
 *
 * @description
 * Sets global configuration settings for both tagsInput and autoComplete directives. It's also used internally to parse and
 *  initialize options from HTML attributes.
 */
tagsInput.provider('tagsInputConfig', function() {
    var globalDefaults = {},
        interpolationStatus = {},
        autosizeThreshold = 3;

    /**
     * @ngdoc method
     * @name tagsInputConfig#setDefaults
     * @description Sets the default configuration option for a directive.
     *
     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.
     * @param {object} defaults Object containing options and their values.
     *
     * @returns {object} The service itself for chaining purposes.
     */
    this.setDefaults = function(directive, defaults) {
        globalDefaults[directive] = defaults;
        return this;
    };

    /**
     * @ngdoc method
     * @name tagsInputConfig#setActiveInterpolation
     * @description Sets active interpolation for a set of options.
     *
     * @param {string} directive Name of the directive to be configured. Must be either 'tagsInput' or 'autoComplete'.
     * @param {object} options Object containing which options should have interpolation turned on at all times.
     *
     * @returns {object} The service itself for chaining purposes.
     */
    this.setActiveInterpolation = function(directive, options) {
        interpolationStatus[directive] = options;
        return this;
    };

    /**
     * @ngdoc method
     * @name tagsInputConfig#setTextAutosizeThreshold
     * @description Sets the threshold used by the tagsInput directive to re-size the inner input field element based on its contents.
     *
     * @param {number} threshold Threshold value, in pixels.
     *
     * @returns {object} The service itself for chaining purposes.
     */
    this.setTextAutosizeThreshold = function(threshold) {
        autosizeThreshold = threshold;
        return this;
    };

    this.$get = ["$interpolate", function($interpolate) {
        var converters = {};
        converters[String] = function(value) { return value; };
        converters[Number] = function(value) { return parseInt(value, 10); };
        converters[Boolean] = function(value) { return value.toLowerCase() === 'true'; };
        converters[RegExp] = function(value) { return new RegExp(value); };

        return {
            load: function(directive, scope, attrs, options) {
                var defaultValidator = function() { return true; };

                scope.options = {};

                angular.forEach(options, function(value, key) {
                    var type, localDefault, validator, converter, getDefault, updateValue;

                    type = value[0];
                    localDefault = value[1];
                    validator = value[2] || defaultValidator;
                    converter = converters[type];

                    getDefault = function() {
                        var globalValue = globalDefaults[directive] && globalDefaults[directive][key];
                        return angular.isDefined(globalValue) ? globalValue : localDefault;
                    };

                    updateValue = function(value) {
                        scope.options[key] = value && validator(value) ? converter(value) : getDefault();
                    };

                    if (interpolationStatus[directive] && interpolationStatus[directive][key]) {
                        attrs.$observe(key, function(value) {
                            updateValue(value);
                            scope.events.trigger('option-change', { name: key, newValue: value });
                        });
                    }
                    else {
                        updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));
                    }
                });
            },
            getTextAutosizeThreshold: function() {
                return autosizeThreshold;
            }
        };
    }];
});


/***
 * @ngdoc service
 * @name tiUtil
 * @module ngTagsInput
 *
 * @description
 * Helper methods used internally by the directive. Should not be called directly from user code.
 */
tagsInput.factory('tiUtil', ["$timeout", function($timeout) {
    var self = {};

    self.debounce = function(fn, delay) {
        var timeoutId;
        return function() {
            var args = arguments;
            $timeout.cancel(timeoutId);
            timeoutId = $timeout(function() { fn.apply(null, args); }, delay);
        };
    };

    self.makeObjectArray = function(array, key) {
        if (!angular.isArray(array) || array.length === 0 || angular.isObject(array[0])) {
            return array;
        }

        var newArray = [];
        array.forEach(function(item) {
            var obj = {};
            obj[key] = item;
            newArray.push(obj);
        });
        return newArray;
    };

    self.findInObjectArray = function(array, obj, key, comparer) {
        var item = null;
        comparer = comparer || self.defaultComparer;

        array.some(function(element) {
            if (comparer(element[key], obj[key])) {
                item = element;
                return true;
            }
        });

        return item;
    };

    self.defaultComparer = function(a, b) {
        // I'm aware of the internationalization issues regarding toLowerCase()
        // but I couldn't come up with a better solution right now
        return self.safeToString(a).toLowerCase() === self.safeToString(b).toLowerCase();
    };

    self.safeHighlight = function(str, value) {
        if (!value) {
            return str;
        }

        function escapeRegexChars(str) {
            return str.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        }

        str = self.encodeHTML(str);
        value = self.encodeHTML(value);

        var expression = new RegExp('&[^;]+;|' + escapeRegexChars(value), 'gi');
        return str.replace(expression, function(match) {
            return match.toLowerCase() === value.toLowerCase() ? '<em>' + match + '</em>' : match;
        });
    };

    self.safeToString = function(value) {
        return angular.isUndefined(value) || value == null ? '' : value.toString().trim();
    };

    self.encodeHTML = function(value) {
        return self.safeToString(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    };

    self.handleUndefinedResult = function(fn, valueIfUndefined) {
        return function() {
            var result = fn.apply(null, arguments);
            return angular.isUndefined(result) ? valueIfUndefined : result;
        };
    };

    self.replaceSpacesWithDashes = function(str) {
        return self.safeToString(str).replace(/\s/g, '-');
    };

    self.isModifierOn = function(event) {
        return event.shiftKey || event.ctrlKey || event.altKey || event.metaKey;
    };

    self.simplePubSub = function() {
        var events = {};
        return {
            on: function(names, handler) {
                names.split(' ').forEach(function(name) {
                    if (!events[name]) {
                        events[name] = [];
                    }
                    events[name].push(handler);
                });
                return this;
            },
            trigger: function(name, args) {
                var handlers = events[name] || [];
                handlers.every(function(handler) {
                    return self.handleUndefinedResult(handler, true)(args);
                });
                return this;
            }
        };
    };

    return self;
}]);

/* HTML templates */
tagsInput.run(["$templateCache", function($templateCache) {
    $templateCache.put('ngTagsInput/tags-input.html',
    "<div class=\"host\" tabindex=\"-1\" ng-click=\"eventHandlers.host.click()\" ti-transclude-append><div class=\"tags\" ng-class=\"{focused: hasFocus}\"><ul class=\"tag-list\"><li class=\"tag-item\" ng-repeat=\"tag in tagList.items track by track(tag)\" ng-class=\"{ selected: tag == tagList.selected }\" ng-click=\"eventHandlers.tag.click(tag)\"><ti-tag-item data=\"::tag\"></ti-tag-item></li></ul><input class=\"input\" autocomplete=\"off\" ng-model=\"newTag.text\" ng-model-options=\"{getterSetter: true}\" ng-keydown=\"eventHandlers.input.keydown($event)\" ng-focus=\"eventHandlers.input.focus($event)\" ng-blur=\"eventHandlers.input.blur($event)\" ng-paste=\"eventHandlers.input.paste($event)\" ng-trim=\"false\" ng-class=\"{'invalid-tag': newTag.invalid}\" ng-disabled=\"disabled\" ti-bind-attrs=\"{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex, spellcheck: options.spellcheck}\" ti-autosize></div></div>"
  );

  $templateCache.put('ngTagsInput/tag-item.html',
    "<span ng-bind=\"$getDisplayText()\"></span> <a class=\"remove-button\" ng-click=\"$removeTag()\" ng-bind=\"::$$removeTagSymbol\"></a>"
  );

  $templateCache.put('ngTagsInput/auto-complete.html',
    "<div class=\"autocomplete\" ng-if=\"suggestionList.visible\"><ul class=\"filter-list\"><li class=\"filter-item\" ng-class=\"{selected: $parent.filter.selected == filter}\" ng-repeat=\"filter in filter.list\" ng-click=\"$parent.filter.selected=filter\">{{attributeList[filter].label}}</li></ul><hr class=\"hr-slim\"><div class=\"clearfix\" style=\"height:10px;\"></div><ul class=\"suggestion-list\"><li class=\"suggestion-item\" ng-show=\"suggestionList.items.length < 1\">No suggestions</li></ul><ul class=\"suggestion-list\"><li class=\"suggestion-item\" ng-repeat=\"item in suggestionList.items track by track(item)\" ng-class=\"{selected: item == suggestionList.selected}\" ng-click=\"addSuggestionByIndex($index)\" ng-mouseenter=\"suggestionList.select($index)\"><ti-autocomplete-match data=\"::item\"></ti-autocomplete-match></li></ul></div>"
  );

  $templateCache.put('ngTagsInput/auto-complete-match.html',
    "<span ng-bind-html=\"$highlight($getDisplayText())\"></span>"
  );
}]);

}());
'use strict';

angular.module('angularDjangoRegistrationAuthApp')
  .service('Validate', function Validate() {
    return {
        'message': {
            'minlength': 'This value is not long enough.',
            'maxlength': 'This value is too long.',
            'email': 'A properly formatted email address is required.',
            'required': 'This field is required.'
        },
        'more_messages': {
            'demo': {
                'required': 'Here is a sample alternative required message.'
            }
        },
        'check_more_messages': function(name,error){
            return (this.more_messages[name] || [])[error] || null;
        },
        validation_messages: function(field,form,error_bin){
            var messages = [];
            for(var e in form[field].$error){
                if(form[field].$error[e]){
                    var special_message = this.check_more_messages(field,e);
                    if(special_message){
                        messages.push(special_message);
                    }else if(this.message[e]){
                        messages.push(this.message[e]);
                    }else{
                        messages.push("Error: " + e)
                    }
                }
            }
            var deduped_messages = [];
            angular.forEach(messages, function(el, i){
                if(deduped_messages.indexOf(el) === -1) deduped_messages.push(el);
            });
            if(error_bin){
                error_bin[field] = deduped_messages;
            }
        },
        'form_validation': function(form,error_bin){
            for(var field in form){
                if(field.substr(0,1) != "$"){
                    this.validation_messages(field,form,error_bin);
                }
            }
        }
    }
});
angular.module('elixir_front')
.controller('AboutController', ['$scope', function($scope) {
	var vm = this;
	window.scrollTo(0, 0);
}]);


angular.module('elixir_front')
.directive('homeInfo', ['$state','$stateParams', function($state, $stateParams) {
	return {
		restrict: 'EA',
		templateUrl: 'components/about/aboutContact.html',
		scope: true,
		link: function(scope, element, attrs) {
			scope.name = attrs["name"];
			scope.initials = attrs["initials"];
			scope.role = attrs["role"];
			scope.image = attrs["image"];

		}
	}
}]);
angular.module('elixir_front')
.controller('CommunityController', ['$scope', function($scope) {
	var vm = this;
    window.scrollTo(0, 0);
}]);
angular.module('elixir_front')
.directive('detailsBar', [function() {
	return {
		restrict: 'A',
		templateUrl: 'components/detailsBar/detailsBar.html',
		link: function(scope, element, attrs) {
			scope.showToolbar = scope.toState.name == "search";
			scope.$watch(function(){
				return scope.toState.name
			}, function(newVal, oldVal){
    			scope.showToolbar = (scope.toState.name == "search");
			}) 
		}
	}
}])
.controller('DetailsBarController', ['$rootScope', '$scope', '$state', '$stateParams', function($rootScope, $scope, $state, $stateParams) {
	var vm = this;
}]);
angular.module('elixir_front')
.controller('DomainBarController', ['$scope', 'djangoAuth', '$stateParams', '$timeout', 'Domain', function($scope, djangoAuth, $stateParams, $timeout, Domain) {
	// reference the service
	var vm = this;
	vm.Domain = Domain;
	
	$timeout(function() {
		Domain.load($stateParams['domain']);
	}, 500);
}])
.service('DomainConnection', ['$resource', function($resource){
	return $resource('/api/d/', null, {
		'query': {
			isArray: true,
			method:'GET'
		},
		'create': {
			method:'POST'
		}
	})
}])
.service('DomainDetailConnection', ['$resource', function($resource){
	return $resource('/api/d/:domain', {'domain': '@domain'}, {
		'query': {
			isArray:false,
			method:'GET'
		},
		'update': {
			method:'PUT'
		},
		'delete': {
			method:'DELETE'
		}
	})
}])
.service('Domain', ['DomainDetailConnection', function(DomainDetailConnection){
	var _this = this;
	this.current = {};
	this.loaded = false;
	this.set = function(domain) {
		_this.current = domain;
	}
	this.load = function(domain) {
		if (typeof domain != 'undefined') {
			var response = DomainDetailConnection.query({'domain':domain}, function(response) {
				_this.set(response.data);
				_this.loaded = true;
			});
		} else {
			_this.loaded = false;
		}
	}
	this.isLoaded = function() {
		return _this.loaded;
	}
	this.hasSubdomain = function() {
		return !_.isEmpty(_this.current);
	}
	this.hasTitle = function() {
		return _this.current.title !== undefined;
	}
	this.hasSubTitle = function() {
		return _this.current.sub_title !== undefined;
	}
	this.hasDescription = function() {
		return _this.current.description !== undefined;
	}
}]);
angular.module('elixir_front')
.service('DomainConnection', ['$resource', function($resource){
	return $resource('/api/d/', null, {
		'query': {
			isArray: true,
			method:'GET'
		},
		'create': {
			method:'POST'
		}
	})
}])
.service('DomainDetailConnection', ['$resource', function($resource){
	return $resource('/api/d/:domain', {'domain': '@domain'}, {
		'query': {
			isArray:false,
			method:'GET'
		},
		'update': {
			method:'PUT'
		},
		'delete': {
			method:'DELETE'
		}
	})
}])
.service('Domain', ['DomainDetailConnection', '$rootScope', function(DomainDetailConnection, $rootScope){
	var _this = this;
	this.current = {};
	this.loaded = false;
	this.set = function(domain) {
		_this.current = domain;
	}
	this.load = function(domain) {
		if (typeof domain != 'undefined') {
			var response = DomainDetailConnection.query({'domain':domain}, function(response) {
				_this.set(response.data);
				_this.loaded = true;
			});
		} else {
			_this.loaded = false;
		}
	}
	this.isLoaded = function() {
		return _this.loaded;
	}
	this.hasSubdomain = function() {
		return !_.isEmpty(_this.current);
	}
	this.hasTitle = function() {
		return _this.current.title !== undefined;
	}
	this.hasSubTitle = function() {
		return _this.current.sub_title !== undefined;
	}
	this.hasDescription = function() {
		return _this.current.description !== undefined;
	}
	this.unload = function() {
		if (this.isLoaded() == true) {
			this.current = {};
			this.loaded = false;
		}
	}
}]);
angular.module('elixir_front')
.controller('HomeController', ['$scope','$state', '$stateParams', function($scope, $state, $stateParams) {
	var vm = this;
	window.scrollTo(0, 0);
}]);

	angular.module('elixir_front')
.directive('homeSearch', ['Query', 'ToolList', 'Highlighting', 'Attribute', '$state', '$stateParams', '$timeout', 'UsedTerms', '$q', 'filterFilter', 'Domain', '$rootScope', '$location', '$anchorScroll', function(Query, ToolList, Highlighting, Attribute, $state, $stateParams, $timeout, UsedTerms, $q, filterFilter, Domain, $rootScope, $location, $anchorScroll) {
	return {
		restrict: 'A',
		templateUrl: 'components/home/homeSearch.html',
		link: function(scope, element, attrs) {
			// reference the Query in the scope
			scope.Query = Query;
			scope.params = null;
			scope.lastParam = null;
			// reference the Attribute in the scope
			scope.Attribute = Attribute;
			scope.ToolList = ToolList;

			var initializing = true

			/* function updateQuery() {
				Query.current = [];
				for (var prop in $stateParams) {
				// iterate through all parameters, skip 'page'
				if ($stateParams.hasOwnProperty(prop)
					&& !_.includes(['page', 'sort', 'ord', 'domain'], prop)
					&& typeof $stateParams[prop] != 'undefined') {
					// Remove tool id from the query
					if (prop == 'q') {
						var list = $stateParams[prop].split('+');
						for (var i in list) {
							if (_.isEmpty(list[i]) == false) {
								Query.current.push({text:list[i], filter:'everything'});
							}
						}
					} else {
						Query.current.push({text:$stateParams[prop], filter:prop});
					}
				}
				}
				// initial highlighting
				Highlighting.set(Query.current);
			}*/


			/*$rootScope.$on('$stateChangeSuccess', function(event, toState, toStateParams, fromState, fromStateParams) {
				if (toState.name === 'tool' || toState.name === 'home') { 
					Query.current = [];
				}
				else if (toState.name === 'search') {
					updateQuery();
				}
			});*/

			//updateQuery();

			function quoteQueryStringValue(v){
				return '"' + v + '"'
			}

			scope.topicNameClicked = function(topic) {
				$state.transitionTo('search', 
					{'topic': quoteQueryStringValue(topic),
					 'page': 1,
					 'sort':'score'
					},
				{
		    	reload: true,
		    	inherit: false,
		    	notify: true
				});
			}

			scope.operationNameClicked = function(operation) {
				$state.transitionTo('search', 
					{'operation': quoteQueryStringValue(operation),
					 'page': 1,
					 'sort':'score'
					},
				{
		    	reload: true,
		    	inherit: false,
		    	notify: true
				});
			}

			scope.navElement = function(elementid) {
				$anchorScroll.yOffset = 75;
				// set the location.hash
				$location.hash(elementid);
			 
				$anchorScroll();
				$location.hash(null);
			}

			// helper function for getting used terms
			function getUsedTerms(term, params) {
				var d = $q.defer();
				var list = []
				params["usedTermName"] = term;
				UsedTerms.get(params, function(response) {
					d.resolve(response.data);
				});
				return d.promise;
			}

			// necessary for filtering suggestions for the autocomplete
			scope.loadSuggestions = function(term, query) {
				var deferred = $q.defer();
				scope.usedTerms[term].then(function(list) {
					deferred.resolve(filterFilter(list,query));
				})
				return deferred.promise;
			}

			function getSuggestions() {
				// get used terms for typeahead
				scope.usedTerms = {};

				// add query and filtering parameters to refine suggestions
				var params = _.clone($stateParams);
				params['page'] = null;
				params['sort'] = null;
				params['ord'] = null;

				// create promises for all suggestions
				scope.usedTerms['everything'] = getUsedTerms('all', params);
				scope.usedTerms['topic'] = getUsedTerms('topic', params);
				scope.usedTerms['operation'] = getUsedTerms('operation', params);
				scope.usedTerms['input'] = getUsedTerms('input', params);
				scope.usedTerms['output'] = getUsedTerms('output', params);
				scope.usedTerms['toolType'] = getUsedTerms('toolType', params);
				scope.usedTerms['language'] = getUsedTerms('language', params);
				scope.usedTerms['accessibility'] = getUsedTerms('accessibility', params);
				scope.usedTerms['cost'] = getUsedTerms('cost', params);
				scope.usedTerms['license'] = getUsedTerms('license', params);
				scope.usedTerms['credit'] = getUsedTerms('credit', params);
				scope.usedTerms['collectionID'] = getUsedTerms('collectionID', params);
				scope.usedTerms['name'] = getUsedTerms('name', params);  
			}

			// custom object necessary for ngTagsInput
			scope.filter = {};
			// initially selected filter
			scope.filter.selected = 'everything';
			// list of filters to display
			scope.filter.list = [
			"everything",
			"topic",
			"operation",
			"input",
			"output",
			"toolType",
			"language",
			"accessibility",
			"cost",
			"license",
			"credit",
			"collectionID",
			"name"	
			];

			// get initial suggestions
			getSuggestions();

			// when tag is added save the filter and reset it to 'everything'
			scope.tagAdded = function(tag) {
				tag['text'] = scope.normalizeTag(tag);
				tag['filter'] = scope.filter.selected;
				scope.filter.selected = 'everything';
			}

			// remove any unwanted characters from the entered tag
			scope.normalizeTag = function(tag) {
				return tag['text'].replace(/\+/g, "")
			}

			scope.doHomeSearch = function() {
				var params = scope.params;
				var no_params = scope.Query.current.length;
				if (no_params > 0 && scope.Query.current[no_params-1].text == scope.lastParam && params != null & params.page != undefined){
					$state.transitionTo('search', params, { notify: true });
				}
			}

			scope.myFunct = function(keyEvent) {
  			if (keyEvent.which === 13){
    			scope.doHomeSearch();
  			}
			}

			// saving the query and filtering to url
			scope.tagsChanged = function() {
				$rootScope.$emit('search-bar-tags-changed', {});
				$timeout(function() {
					var params =  {};
					scope.params = null;
					params['page'] = 1;
					params['sort'] = $stateParams['sort'];
					if (params['sort'] == undefined) {
						params['sort'] = 'score';
					};
					if (scope.Query.current.length == 0) {
						params['sort'] = undefined;
						params['page'] = undefined;
					};
					params['ord'] = $stateParams['ord'];
					params['domain'] = $stateParams['domain'];
							// add each tag from the search bar to the url
							for (var i in scope.Query.current) {
								scope.lastParam = scope.Query.current[i].text;
								// if tag is 'everything' put it under q
								if (scope.Query.current[i].filter == 'everything') {
									// if there already is a 'everything' tag, add new ones separating them with a dash
									if (params['q'] && params['q'].length > 0) {
										params['q'] += "+" + scope.Query.current[i].text;
									} else {
										params['q'] = scope.Query.current[i].text
									}
								} else {
									params[scope.Query.current[i].filter] = scope.Query.current[i].text;
								}
							}

							scope.params = params;
							// update url
							//$state.transitionTo('search', params, { notify: true });
							// add query elements to list of terms to highlight
							Highlighting.set(Query.current);
							$timeout(function() {
								// get more refined suggestions
								getSuggestions();
								// refresh tool list
								ToolList.refresh();
							})
						})
			}
		}
	}
}]);
angular.module('elixir_front')
.controller('ProfileController', ['$scope', '$state', 'djangoAuth', 'DisownToolService', 'User', function($scope, $state, djangoAuth, DisownToolService, User) {
	$scope.profile = {};
	$scope.loading = true;
	$scope.User = User;
	djangoAuth.profile()
	.then(function (response) {
		$scope.profile = response;
		$scope.loading = false;
	}, function (response) {
		$scope.loading = false;
	});

	$scope.disownEntry = function(entry) {
		if (!confirm("Are you sure you want to disown this resource?")){
			return;
		}

		DisownToolService.disown({id: entry.id, version: entry.versionId}, function(response) {
			$scope.profile.resources = _.difference($scope.profile.resources, [entry]);
		}, function(response) {
			alert("Failed to disown " + entry.name + ". Please check your connection and try again later.");
		});
	}
}]);
angular.module('elixir_front')
.directive('navigationBar', [function() {
	return {
		restrict: 'A',
		templateUrl: 'components/navigationBar/navigationBar.html',
		link: function(scope, element, attrs) {
			scope.showSearch = scope.toState.name != "home";
			scope.$watch(function(){
				return scope.toState.name
			}, function(newVal, oldVal){
    			scope.showSearch = (scope.toState.name != "home");
			}) 
		}
	}
}])
.controller('NavbarController', ['$scope', 'djangoAuth', 'User', '$stateParams', '$timeout', 'Domain', '$state', function($scope, djangoAuth, User, $stateParams, $timeout, Domain, $state) {
	// reference the service
	var vm = this;

	$scope.User = User;
	$scope.Domain = Domain;
	
	$timeout(function() {
		Domain.load($stateParams['domain']);
	}, 500);

	$scope.logoutButtonClick = function() {
		djangoAuth.logout();
	};

	$scope.homeButtonClicked = function() {
		$scope.Domain.unload();
		$state.go('home');
	};

	$scope.aboutButtonClicked = function() {
		$scope.Domain.unload();
		$state.go('about');
	};


}]);
angular.module('elixir_front')
.directive('pageFooter', [function() {
	return {
		restrict: 'A',
		templateUrl: 'components/pageFooter/pageFooter.html',
		link: function(scope, element, attrs) {

		}
	}
}])
angular.module('elixir_front.services')
// Gets stats info from the server.
.factory('Stats', ['$resource', function($resource){
	return $resource('/api/stats', null, {
		'query': { 
			isArray:false,
			method:'GET'
		}
	})
}])
.factory('StatsTotalEntries', ['$resource', function($resource){
	return $resource('/api/stats/total-entries', null, {
		'query': { 
			isArray:true,
			method:'GET'
		}
	})
}])
.factory('StatsUserData', ['$resource', function($resource){
	return $resource('/api/stats/users', null, {
		'query': { 
			isArray:true,
			method:'GET'
		}
	})
}])
.factory('TotalAnnotationsStatsData', ['$resource', function($resource){
	return $resource('/api/stats/annotation-count', null, {
		'query': { 
			isArray:true,
			method:'GET'
		}
	})
}])
// Get and manage the stats data from the server.
.service('StatsDataSource', ['$stateParams', 'Stats', 'StatsTotalEntries', 'StatsUserData', 'TotalAnnotationsStatsData', function($stateParams, Stats, StatsTotalEntries, StatsUserData, TotalAnnotationsStatsData) {
	var _this = this;
	this.isLoadingData = true;
	this.isLoadingTotalEntriesData = true;
	this.isLoadingUserStatsData = true;
	this.isLoadingTotalAnnotationsStats = true;
	this.statsData = {};
	this.totalEntriesData = {};
	this.userStatsData = {};
	this.totalAnnotationsStatsData = {};
	this.totalAnnotationsCount = function() {
		var totalCount = 0;
		for (var key in this.statsData.totalAnnotationCount) {
			var value = this.statsData.totalAnnotationCount[key];
			totalCount += value;
		}
		return totalCount;
	}
	// Operations
	this.fetchStatsData = function(completion) {
		this.isLoadingData = true;
		var response = Stats.query($stateParams, function() {
			_this.statsData = response;
			_this.isLoadingData = false;
			completion()
		});
	}
	this.fetchTotalEntriesData = function(completion) {
		this.isLoadingTotalEntriesData = true;
		var response = StatsTotalEntries.query($stateParams, function() {
			_this.totalEntriesData = response;
			_this.isLoadingTotalEntriesData = false;
			completion()
		});
	}
	this.fetchUserStatsData = function(completion) {
		this.isLoadingUserStatsData = true;
		var response = StatsUserData.query($stateParams, function() {
			_this.userStatsData = response;
			_this.isLoadingUserStatsData = false;
			completion();
		});
	}
	this.fetchTotalAnnotationsStatsData = function(completion) {
		this.isLoadingTotalAnnotationsStats = true;
		var response = TotalAnnotationsStatsData.query($stateParams, function() {
			_this.totalAnnotationsStatsData = response;
			_this.isLoadingTotalAnnotationsStats = false;
			completion();
		});
	}
}])
// Controller for the stats website.
angular.module('elixir_front.controllers').controller('StatsController', ['$scope', '$http', 'StatsDataSource', function($scope, $http, StatsDataSource) {
	// Initialization
	var _this = this;
	$scope.labels = [];
	$scope.labelsUsers = [];
	$scope.series = ['Total entries'];
	$scope.seriesEDAM = ['EDAM annotations'];
	$scope.seriesEDAMBreakdown = ['Data Type annotations', 'Topic annotations', 'Function annotations', 'Format annotations'];
	$scope.seriesUsers = ['Total contributors count', 'New contributors this month'];
	$scope.seriesTotalAnnotationDetail = ['Name', 'Description', 'Homepage', 'Tool Type', 'Unique Id', 'Topic', 'Publication', 'Contact', 'Operation', 'Documentation', 'Operating System', 'Input output', 'Code availability', 'Accessibility', 'Data format', 'Community', 'Downloads', 'Total'];
	$scope.seriesTotalAnnotation = ['Total'];
	$scope.data = [[]];
	$scope.dataEDAM = [[]];
	$scope.dataEDAMBreakdown = [[]];
	$scope.dataUsers = [[]];
	$scope.dataTotalAnnotation = [[]];
	$scope.dataTotalAnnotationDetail = [[]];
	$scope.totalAnnotationOptions = {
		tooltips: {
			titleFontSize: 10,
			bodyFontSize: 9,
			bodySpacing: 0
		}
	};
	$scope.statsDataSource = StatsDataSource;
	$scope.statsDataSource.fetchStatsData(function(){
		_this.initializeTopContributorsStatsGraph();
	});
	$scope.statsDataSource.fetchTotalEntriesData(function() {
		_this.initializeTotalEntriesGraph();
	});
	$scope.statsDataSource.fetchUserStatsData(function() {
		_this.initializeUserStatsGraph();
	});
	$scope.statsDataSource.fetchTotalAnnotationsStatsData(function() {
		_this.initializeTotalAnnotationsStatsGraph();
		_this.initializeTotalAnnotationsDetailStatsGraph();
	});
	$scope.topContributorsLabels = [];
	$scope.topContributorsData = [];
	$scope.topContributorsOptions = {legend: {display: true}};
	// Total Entries Grpah handling
	this.initializeTotalEntriesGraph = function() {
		var data = $scope.statsDataSource.totalEntriesData;
		$scope.labels = _.map(data, function(x) {
			var date = x.date.split('T')[0];
			return moment(date).format("MMM YY");
		});
		$scope.data = [_.map(data, function(x) {
			return x.entriesCount;
		})];
		$scope.dataEDAM = [_.map(data, function(x) {
			return x.edamAnnotationsCount;
		})];
		$scope.dataEDAMBreakdown = [_.map(data, function(x) {
			return x.dataTypeAnnotationsCount;
		}),
		_.map(data, function(x) {
			return x.topicAnnotationsCount;
		}),
		_.map(data, function(x) {
			return x.functionAnnotationsCount;
		}),
		_.map(data, function(x) {
			return x.formatAnnotationsCount;
		})];
	};
	// Total Entries Grpah handling
	this.initializeUserStatsGraph = function() {
		var data = $scope.statsDataSource.userStatsData;
		$scope.labelsUsers = _.map(data, function(x) {
			var date = x.date.split('T')[0];
			return moment(date).format("MMM YY");
		});
		$scope.dataUsers = [_.map(data, function(x) {
			return x.totalUsersCount;
		}),
		_.map(data, function(x) {
			return x.newUsersCount;
		})];
	};
	// Top contributors data.
	this.initializeTopContributorsStatsGraph = function() {
		var contributorData = $scope.statsDataSource.statsData.topContributors;
		$scope.topContributorsLabels = _.map(contributorData, function(x) {
			return x.domain;
		});
		$scope.topContributorsData = _.map(contributorData, function(x) {
			return x.count;
		});
	};
	// Total annotations data.
	this.initializeTotalAnnotationsStatsGraph = function() {
		var annotationData = $scope.statsDataSource.totalAnnotationsStatsData
		$scope.dataTotalAnnotation = [_.map(annotationData, function(x) {
			var data = x;
			var totalCount = 0;
			for (var key in data) {
				if (key != 'date' && !isNaN(data[key])) {
					totalCount += data[key];
				}
			}
			return totalCount;
		})];
	};
	this.initializeTotalAnnotationsDetailStatsGraph = function() {
		var annotationData = $scope.statsDataSource.totalAnnotationsStatsData
		$scope.dataTotalAnnotationDetail = [_.map(annotationData, function(x) {
			return x.nameAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.descriptionAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.homepageAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.toolTypeAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.uniqueIDAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.topicAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.publicationAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.contactAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.operationAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.documentationAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.operatingSystemAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.inputOutputAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.codeAvailabilityAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.accessibilityAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.dataFormatsAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.communityAnnotationCount;
		}),
		_.map(annotationData, function(x) {
			return x.downloadsAnnotationCount;
		})];
	};
}]);




	angular.module('elixir_front')
.directive('searchBar', ['Query', 'ToolList', 'Highlighting', 'Attribute', '$state', '$stateParams', '$timeout', 'UsedTerms', '$q', 'filterFilter', 'Domain', '$rootScope', function(Query, ToolList, Highlighting, Attribute, $state, $stateParams, $timeout, UsedTerms, $q, filterFilter, Domain, $rootScope) {
	return {
		restrict: 'A',
		templateUrl: 'components/searchBar/searchBar.html',
		link: function(scope, element, attrs) {

			// reference the Query in the scope
			scope.Query = Query;
			// reference the Attribute in the scope
			scope.Attribute = Attribute;
			scope.ToolList = ToolList;

			var initializing = true

			function updateQuery() {
				Query.current = [];
				for (var prop in $stateParams) {
				// iterate through all parameters, skip 'page'
				if ($stateParams.hasOwnProperty(prop)
					&& !_.includes(['page', 'sort', 'ord', 'domain'], prop)
					&& typeof $stateParams[prop] != 'undefined') {
					// Remove tool id from the query
					if (prop == 'q') {
						var list = $stateParams[prop].split('+');
						for (var i in list) {
							if (_.isEmpty(list[i]) == false) {
								Query.current.push({text:list[i], filter:'everything'});
							}
						}
					} else {
						Query.current.push({text:$stateParams[prop], filter:prop});
					}
				}
				}
				// initial highlighting
				Highlighting.set(Query.current);
			}


			$rootScope.$on('$stateChangeSuccess', function(event, toState, toStateParams, fromState, fromStateParams) {
				if (toState.name !== 'search') { 
					Query.current = [];
					ToolList.refresh();
				}
				else if (toState.name === 'search') {
					updateQuery();
				}
			});

			updateQuery();

			// helper function for getting used terms
			function getUsedTerms(term, params) {
				var d = $q.defer();
				var list = []
				params["usedTermName"] = term;
				UsedTerms.get(params, function(response) {
					d.resolve(response.data);
				});
				return d.promise;
			}

			// necessary for filtering suggestions for the autocomplete
			scope.loadSuggestions = function(term, query) {
				var deferred = $q.defer();
				scope.usedTerms[term].then(function(list) {
					deferred.resolve(filterFilter(list,query));
				})
				return deferred.promise;
			}

			function getSuggestions() {
				// get used terms for typeahead
				scope.usedTerms = {};

				// add query and filtering parameters to refine suggestions
				var params = _.clone($stateParams);
				params['page'] = null;
				params['sort'] = null;
				params['ord'] = null;

				// create promises for all suggestions
				scope.usedTerms['everything'] = getUsedTerms('all', params);
				scope.usedTerms['topic'] = getUsedTerms('topic', params);
				scope.usedTerms['operation'] = getUsedTerms('operation', params);
				scope.usedTerms['input'] = getUsedTerms('input', params);
				scope.usedTerms['output'] = getUsedTerms('output', params);
				scope.usedTerms['toolType'] = getUsedTerms('toolType', params);
				scope.usedTerms['language'] = getUsedTerms('language', params);
				scope.usedTerms['accessibility'] = getUsedTerms('accessibility', params);
				scope.usedTerms['cost'] = getUsedTerms('cost', params);
				scope.usedTerms['license'] = getUsedTerms('license', params);
				scope.usedTerms['credit'] = getUsedTerms('credit', params);
				scope.usedTerms['collectionID'] = getUsedTerms('collectionID', params);
				scope.usedTerms['name'] = getUsedTerms('name', params);  
			}

			// custom object necessary for ngTagsInput
			scope.filter = {};
			// initially selected filter
			scope.filter.selected = 'everything';
			// list of filters to display
			scope.filter.list = [
			"everything",
			"topic",
			"operation",
			"input",
			"output",
			"toolType",
			"language",
			"accessibility",
			"cost",
			"license",
			"credit",
			"collectionID",
			"name"	
			];

			// get initial suggestions
			getSuggestions();

			// when tag is added save the filter and reset it to 'everything'
			scope.tagAdded = function(tag) {
				tag['text'] = scope.normalizeTag(tag);
				tag['filter'] = scope.filter.selected;
				scope.filter.selected = 'everything';
			}

			// remove any unwanted characters from the entered tag
			scope.normalizeTag = function(tag) {
				return tag['text'].replace(/\+/g, "")
			}

			// saving the query and filtering to url
			scope.tagsChanged = function() {
				$rootScope.$emit('search-bar-tags-changed', {});
				$timeout(function() {
					var params =  {};
					params['page'] = 1;
					params['sort'] = $stateParams['sort'];
					if (params['sort'] == undefined) {
						params['sort'] = 'score';
					};
					if (scope.Query.current.length == 0) {
						params['sort'] = undefined;
						params['page'] = undefined;
					};
					params['ord'] = $stateParams['ord'];
					params['domain'] = $stateParams['domain'];
							// add each tag from the search bar to the url
							for (var i in scope.Query.current) {
								// if tag is 'everything' put it under q
								if (scope.Query.current[i].filter == 'everything') {
									// if there already is a 'everything' tag, add new ones separating them with a dash
									if (params['q'] && params['q'].length > 0) {
										params['q'] += "+" + scope.Query.current[i].text;
									} else {
										params['q'] = scope.Query.current[i].text
									}
								} else {
									params[scope.Query.current[i].filter] = scope.Query.current[i].text;
								}
							}
							// update url
							$state.transitionTo('search', params, { notify: true });
							// add query elements to list of terms to highlight
							Highlighting.set(Query.current);
							$timeout(function() {
								// get more refined suggestions
								getSuggestions();
								// refresh tool list
								ToolList.refresh();
							})
						})
			}
		}
	}
}]);
angular.module('elixir_front')
.controller('ToolPageController', ['$scope', '$state', '$timeout', '$stateParams', 'Tool', 'User', 'CheckUserEditingRights', 'ResourceRequestProvider', 'ngMeta', 'Query', 'Covid', '$http',  function($scope, $state, $timeout, $stateParams, Tool, User, CheckUserEditingRights, ResourceRequestProvider, ngMeta, Query, Covid, $http) {
	$scope.notFound = false;
	$scope.versions = [];
	$scope.CheckUserEditingRights = CheckUserEditingRights;
	$scope.editingRequestedSuccess = null; 

	

	$scope.User = User;
	$scope.Covid = Covid;
	$scope.elixirCommunityIndex = {
		"3D-BioInfo": "3d-bioinfo",
		"Federated Human Data": "human-data",
		"Galaxy": "galaxy",
		"Human Copy Number Variation": "hcnv",
		"Intrinsically Disordered Proteins": "intrinsically-disordered-proteins",
		"Marine Metagenomics": "marine-metagenomics",
		"Metabolomics": "metabolomics",
		"Microbial Biotechnology": "microbial-biotechnology",
		"Plant Sciences": "plant-sciences",
		"Proteomics": "proteomics",
		"Rare Diseases": "rare-diseases"
	}

	$scope.hasRRID = function(){
		for (var index in $scope.software.otherID) {
			if ($scope.software.otherID[index].type.toLowerCase() == 'rrid') {
				return true
			}
		}

		return false;
	}

	$scope.confidenceClass = function() {
		if ($scope.software.confidence_flag === 'high'){
			return 'alert-info'
		}

		if ($scope.software.confidence_flag === 'medium'){
			return 'alert-warning'
		}

		return 'alert-danger';
	}

	function quoteQueryStringValue(v){
		return '"' + v + '"'
	}

	function stripEdam(t){
		return t.replace("http://edamontology.org/", "");
	}
	// go to 404 in special case when URL is /tool/
	if ($stateParams.id.length == 0) {
		$state.go('404');
	}
	
	$scope.topicNameClicked = function(topic) {
		$state.go('search', {'topicID': quoteQueryStringValue(stripEdam(topic.uri))});
	}

	$scope.functionNameClicked = function(functionName) {
		$state.go('search', {'operationID': quoteQueryStringValue(stripEdam(functionName.uri))});
	}

	$scope.inputNameClicked = function(inputName) {
		//$state.go('search', {'inputDataType': inputName.data.term});
		$state.go('search', {'inputDataTypeID': quoteQueryStringValue(stripEdam(inputName.data.uri)) });
	}

	$scope.inputFormatNameClicked = function(formatName) {
		//$state.go('search', {'inputDataFormat': formatName.term});
		$state.go('search', {'inputDataFormatID': quoteQueryStringValue(stripEdam(formatName.uri)) });
	}

	$scope.outputFormatNameClicked = function(formatName) {
		$state.go('search', {'outputDataFormatID': quoteQueryStringValue(stripEdam(formatName.uri))});
	}

	$scope.outputNameClicked = function(outputName) {
		$state.go('search', {'outputDataTypeID': quoteQueryStringValue(stripEdam(outputName.data.uri))});
	}

	$scope.toolsNameClicked = function(functionName) {
		$state.go('search', {'name': $scope.software.name});
	}

	$scope.collectionNameClicked = function(collectionName) {
		$state.go('search', {'collectionID': '"'+ collectionName + '"'});
	}

	$scope.creditNameClicked = function(creditName) {
		var url = $state.href('search', {'credit': '"'+ creditName + '"'});
		window.open(url,'_blank');
	}

	$scope.publicationDetailsExist = function() {
		for (var index in $scope.software.publication) {
			if ($scope.software.publication[index].metadata != null) {
				return true;
			}
		}
		return false;
	}

	// TODO: needs to keep it DRY and in a service
	// function to clean all nulls from tool gotten from API
	function cleanNulls (object) {
		for (var key in object) {
			if (object[key] == null) {
				delete object[key]
			} else if (object[key].constructor === Array) {
				if (object[key].length == 0) {
					delete object[key]
				} else {
					for (var i in object[key]) {
						cleanNulls(object[key][i])
					}
				}
			} else if (typeof object[key] === 'object') {
				cleanNulls(object[key]);
			}
		}
	}

	var initAltmetricsScore = function() {
		var script = document.createElement('script');
		script.type = 'text/javascript';
		script.src = "https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js";
		document.body.appendChild(script);
	}

	var initDimensionsAI = function() {
		var script = document.createElement('script');
		script.type = 'text/javascript';
		script.src = "https://badge.dimensions.ai/badge.js";
		document.body.appendChild(script);
	}

	$scope.altMetricsScorePublication = function() {
		var publication = ""
		for (var index in $scope.software.publication) {
			var publication = $scope.software.publication[index];
			if (publication.type == "Primary" && publication.doi) {
				publication = publication;
				break;
			}
			else {
				publication = publication;
			}
		}
		return publication;
	}

	$scope.versionSelected = function(versionId) {
		$state.go('tool', {id: $scope.software.id, version: versionId});
	}

	$scope.shouldLicenseBeALink = function(license) {
			return !_.includes(['Freeware','Proprietary', 'Other','Not licensed'], license);
	}

	$scope.setMetadataForSoftware = function(software) {
		ngMeta.setTitle(software.name, ' · bio.tools');
		ngMeta.setTag('description', software.description);
		ngMeta.setTag('og:title', software.name);
		ngMeta.setTag('og:description', software.description);
	}

	// get tool
	$scope.software = Tool.get($stateParams, function(response) {
		// success handler
		initAltmetricsScore();
		//initDimensionsAI();
		//window.__dimensions_embed.addBadges();
		//window.__dimensions_embed.addBadges();
		cleanNulls($scope.software);
		$scope.setMetadataForSoftware($scope.software);
		//$timeout(function(){ window.OpEB_widgets.OpEB.apply(); }, 100);*/

		$timeout(function(){ window.__dimensions_embed.addBadges(); }, 100);
		/*$timeout(function(){ window.OpEB_widgets.OpEB.apply(); }, 100);*/
	}, function(response) {
		// error handler
		if (response.status == 404) {
			$scope.notFound = true;
		}
	});

	$scope.requestOwnership = function(resourceId) {
		if (confirm("We recommend that only the tool developers/maintainers request ownership.\nAll other users should request edit-rights.\nAre you sure you want to request ownership of this tool?")){
			$scope.ownershipRequestedSuccess = null;
			ResourceRequestProvider.requestOwnership(resourceId).then(function successCallback(response) {
				$scope.ownershipRequestedSuccess = true;
			}, function errorCallback(response) {
				$scope.ownershipRequestedSuccess = false;
			});
		}
	}

	$scope.requestEditing = function(resourceId) {
		$scope.editingRequestedSuccess = null; 
		ResourceRequestProvider.requestEditingRights(resourceId).then(function successCallback(response) {
			$scope.editingRequestedSuccess = true;
		}, function errorCallback(response) {
			$scope.editingRequestedSuccess = false;
		});
	}

	// Call the API t retrieve and inject JSON-LD semantic annotations (Bioschemas tool profile)
	$scope.software.$promise.then(function(data) {
     		// console.log('Success: '+JSON.stringify(data));
     		// console.log("calling API "+"/api/"+data.biotoolsID+"?format=jsonld");
			$http.get("/api/"+data.biotoolsID+"?format=jsonld").then(function(response) {
				// console.log(response.data);

				var script = document.createElement('script');
				script.type = 'application/ld+json';
				script.innerHTML = JSON.stringify(response.data);

				document.getElementsByTagName('head')[0].appendChild(script);

			 });
		}, function (reason) {
     		console.log('ERROR: '+JSON.stringify(reason));
   	});

}])
.directive("publicationDetailCallout", function(){
	return {
		restrict: 'A',
		transclude: true,
		templateUrl: 'components/toolPage/partials/publicationDetailCallout.html',
		controller: ['$scope', function($scope) {
			$scope.status = "... More";
			$scope.expandable_status = "expandable-summary";

			var initDimensionsAI = function() {
				var script = document.createElement('script');
				script.type = 'text/javascript';
				script.src = "https://badge.dimensions.ai/badge.js";
				document.body.appendChild(script);
			}

			//initDimensionsAI();
			$scope.toggleStatus = function(){
				if ($scope.status == "... More"){
					$scope.status = "Less";
					$scope.expandable_status = "";
				}else{
					$scope.status = "... More";
					$scope.expandable_status = "expandable-summary";
				}
			}

			$scope.getDoi = function(){
				return $scope.publication.doi;
			}
		}],
		link: function($scope, element, attrs) {
				
				//window.__dimensions_embed.addBadges();

		}
	};
})
.directive("toolPageLinkCallout", function(){
	return {
		restrict: 'A',
		transclude: true,
		template: function(elem, attr){
			return '<div class="bs-callout-sm bs-callout-primary" style="border-left-color: ' + attr.color + ';">' +
			'<div class="tool-page-callout-header" style="color: black;">' + 
			'<a target="_blank" href="' + attr.url + '" tooltips tooltip-side="top" tooltip-content="' + attr.url + '">' + attr.name + ' › </a>' +
			'<i ng-show="' +  attr.toshow  + '" class="fa fa-question-circle" aria-hidden="true" style="font-size: 100%; margin-left: 0.5em; color: ' + attr.color + ';" tooltips tooltip-side="top" tooltip-content="' + attr.comment + '"></i>' +
			'</div>' + 
			'</div>';
		},
		replace: true
	};
})
.directive("toolPageNewLinkCallout", function(){
	return {
		restrict: 'A',
		scope:{
			'url': '=?',
			'types':'=?',
			'toshow':'@?',
			'color':'@?',
			'cssclass':"@?",
			'note':'=?',
			'hovertext':'@?'
		},
		templateUrl: 'components/toolPage/partials/toolPageNewLinkCallout.html',
		replace: true
	};
})
.directive("toolPagePublicationCallout", function(){
	return {
		restrict: 'A',
		scope:{
				'pmcid': '=?',
				'doi':'=?',
				'pmid':'=?',
				'types':'=?',
				'color':'@?',
				'note':'=?'
		},
		templateUrl: 'components/toolPage/partials/toolPagePublicationCalloutHTML.html',
		replace: true
	};
})
.directive("toolPageContactCallout", function(){
	return {
		restrict: 'A',
		transclude: true,
		template: function(elem, attr){
			var callout = '<div class="bs-callout-sm bs-callout-primary" style="border-left-color: ' + attr.color + ';">';
			callout += '<div ng-show="' + attr.name + '" class="tool-page-callout-header" style="color: black;">{{::' + attr.name + '}}</div>';
			callout += '<div class="tool-page-callout-text">';
			callout += '<span ng-show="' + attr.phone + '">{{::' + attr.phone + '}}';
			callout += '<span ng-show="' + attr.email + ' || ' + attr.url + '" style="color: #CCCCCC;"> | </span></span>';
			callout += '<span ng-show="' + attr.email + '"><i class="fa fa-envelope-o" aria-hidden="true"></i> {{' + attr.email +'.replace(\'@\', \' at \') }}';
			callout += '<span ng-show="' + attr.url + '" style="color: #CCCCCC;"> | </span></span>';
			callout += '<span ng-show="' + attr.url + '"><a href="{{::' + attr.url + '}}">Link › </a></span>';
			callout += '</div>';
			callout += '</div>';
			return callout;
		},
		replace: true
	};
})
.directive("toolPageCreditCallout", function(){
	return {
		restrict: 'A',
		transclude: true,
		template: function(elem, attr){
			var callout = '<div class="bs-callout-sm bs-callout-primary" style="border-left-color: ' + attr.color + ';">';
			callout += '<div ng-show="' + attr.name + '" class="tool-page-callout-header" style="color: black;"><a href="" ng-click="creditNameClicked(credit.name)">{{' + attr.name + '}}</a>';
			callout += '<i ng-show="' +  attr.toshow  + '" class="fa fa-question-circle" aria-hidden="true" style="font-size: 100%; margin-left: 0.5em; color: ' + attr.color + ';" tooltips tooltip-side="top" tooltip-content="' + attr.comment + '"></i>';
			callout += '<span ng-show="' + attr.typeentity + ' && ' + attr.typeentity + ' != \'Person\'">';
			callout += '<span ng-show="' + attr.typeentity + '" style="color: #CCCCCC;"> | </span>'; 
			callout += '<span ng-show="' + attr.typeentity + '">{{' + attr.typeentity + '}}</span>';
			callout += '</div>';
			callout += '<div class="tool-page-callout-text">';
			callout += '<span ng-show="' + attr.typerole.count + ' != 0" ng-repeat="role in ' + attr.typerole + '">{{role}}{{$last ? "" : ", "}}';
			callout += '<span ng-show="' + attr.email + ' || ' + attr.url + ' || ' + attr.orcidid + ' || ' + attr.gridid + '" style="color: #CCCCCC;"> | </span></span>';
			callout += '<span ng-show="' + attr.email + '"><i class="fa fa-envelope-o" aria-hidden="true"></i> {{' + attr.email +'.replace(\'@\', \' at \') }}';
			callout += '<span ng-show="' + attr.url + ' || ' + attr.orcidid + ' || ' + attr.gridid + '" style="color: #CCCCCC;"> | </span></span>';
			callout += '<span ng-show="' + attr.url + '"><a href="{{' + attr.url + '}}" target="_blank">Link › </a>';
			callout += '<span ng-show="' + attr.orcidid + ' || ' + attr.gridid + '" style="color: #CCCCCC;"> | </span></span>';
			callout += '<span ng-show="' + attr.orcidid + '"><a href="{{' + attr.orcidid + '}}" target="_blank">ORCID ›</a></span>';
			callout += '<span ng-show="' + attr.gridid + '" style="color: #CCCCCC;"> | </span></span>';
			callout += '<span ng-show="' + attr.gridid + '"><a href="https://www.grid.ac/institutes/{{' + attr.gridid + '}}" target="_blank">gridid ›</a></span>';
			callout += '<span ng-show="' + attr.rorid + '" style="color: #CCCCCC;"> | </span></span>';
			callout += '<span ng-show="' + attr.rorid + '"><a href="https://ror.org/{{' + attr.rorid + '}}" target="_blank">rorid ›</a></span>';
			callout += '<span ng-show="' + attr.fundrefid + '" style="color: #CCCCCC;"> | </span></span>';
			callout += '<span ng-show="' + attr.fundrefid + '"><a href="https://dx.doi.org/{{' + attr.fundrefid + '}}" target="_blank">fundrefid ›</a></span>';
			callout += '</div>';
			callout += '</div>';
			return callout;
		},
		replace: true
	};
});